The REST API lets you interact with Parse from anything that can send an HTTP request. There are many things you can do with the REST API. For example:

A mobile website can access Parse data from Javascript.
A webserver can show data from Parse on a website.
You can upload large amounts of data that will later be consumed in a mobile app.
You can download recent data to run your own custom analytics.
Applications written in any programming language can interact with data on Parse.
You can export all of your data if you no longer want to use Parse.

Run your app. A new object of class TestObject will be sent to the Parse Cloud and saved. When you're ready, click the button below to test if your data was sent.

The Grand Prize-winning app was a monitoring system for Energize the Chain. They are working to build a network of refrigerators to supply vaccines throughout parts of Africa and India without reliable electric infrastructure. To power the refrigerators, they will be partnering with telecom companies, using their cell towers’ generators for power. With the cell towers, they can also transmit monitoring data.

Parse is proud to be partnering with 

Whenever a user sends a message to another user, we use push notifications to alert them.

What do you love most about Parse?

By far, the most amazing thing about Parse is the time it saves you in development.

Any app developer would be crazy to not check out Parse before developing their own backend. Even if only a few of the features apply to you, using it will probably be a win.

Players loved the immersive experience and SpaceCraft was an overnight success. In its second version, World of SpaceCraft supports multiple battles with many bases. Push notifications needed to be more targeted: if a nuclear launch was detected, only one base needed to be notified; and if a building is under attack, only combatants should be notified. Parse’s advanced targeting makes this task easy.

Cloud Code Guide

What is Cloud Code?

Parse's vision is to let developers build any mobile app without dealing with servers. For complex apps, sometimes you just need a bit of logic that isn't running on a mobile device. Cloud Code makes this possible.

Cloud Code is easy to use because it's built on the same JavaScript SDK that powers thousands of apps. The only difference is that this code runs in the Parse Cloud rather than running on a mobile device. When you update your Cloud Code, it becomes available to all mobile environments instantly. You don't have to wait for a new release of your application. This lets you change app behavior on the fly and add new features faster.

Even if you're only familiar with mobile development, we hope you'll find Cloud Code straightforward and easy to use.

Getting Started

Installing the Command Line Tool

On the computer you use for development, you will need to install Parse's command line tool. This will let you manage your code in the Parse Cloud. Run this command:

curl -s https://www.parse.com/downloads/cloud_code/installer.sh | sudo /bin/bash
This installs a tool named "parse" to /usr/local/bin/parse. There's no other junk, so to uninstall, just delete that file.

Setting Up Cloud Code

The next step is to create a directory to store the code that you will run in the cloud. The command parse new sets up this directory, and will prompt you to pick which app you are creating Cloud Code for:

$ parse new MyCloudCode
Email: ninja@gmail.com
Password:
1:MyApp
Select an App: 1
$ cd MyCloudCode
Use the email address and password for your Parse account to log in. This will create a directory called MyCloudCode in the current directory. Several files are automatically created for you:

-config/
  global.json
-cloud/
  main.js
Typically, you'll just be editing main.js. This file stores all of your Cloud Code. The json files contain configuration information that you shouldn't normally need to deal with. For now, just check that these files were created successfully. If you're using source control, you can check all of these files in.

A Simple Function

Following ancient tradition, let's see how to run the simplest possible function in the cloud. If you take a look at cloud/main.js, you'll see an example function that just returns a string:

Parse.Cloud.define("hello", function(request, response) {
  response.success("Hello world!");
});
To deploy the code from your machine to the Parse Cloud, run:

$ parse deploy
To run this function once it's deployed, run:

curl -X POST \
  -H "X-Parse-Application-Id: EGmUWB7VvrlWfvnjxhC9lBwsoN4FnoMeklYoUJ3H" \
  -H "X-Parse-REST-API-Key: ECQ4ObX9ZHGEnApfT2PJbFuaZmE6ISE2N4hMovta" \
  -H "Content-Type: application/json" \
  -d '{}' \
  https://api.parse.com/1/functions/hello
Show examples for:  Use keys for:  
You should see this response:

{
  "result": "Hello world!"
}
Congratulations! You have successfully deployed and run Cloud Code.

This is a good time to play around with the deployment cycle. Try changing "Hello world!" to a different string, then deploy and run the function again to get a different result. The whole JavaScript SDK is available in Cloud Code, so there's a lot you can do. We'll go over some examples in more detail below.

Cloud Functions

Let's look at a slightly more complex example where Cloud Code is useful. One reason to do computation in the cloud is so that you don't have to send a huge list of objects down to a device if you only want a little bit of information. For example, let's say you're writing an app that lets people review movies. A single Review object could look like:

{
  "movie": "The Matrix",
  "stars": 5,
  "comment": "Too bad they never made any sequels."
}
If you wanted to find the average number of stars for The Matrix, you could query for all of the reviews, and average the stars on the device. However, this uses a lot of bandwidth when you only need a single number. With Cloud Code, we can just pass up the name of the movie, and return the average star rating.

Cloud functions accept a JSON parameters dictionary on the request object, so we can use that to pass up the movie name. The entire Parse JavaScript SDK is available in the cloud environment, so we can use that to query over Review objects. Together, the code to implement averageStars looks like:

Parse.Cloud.define("averageStars", function(request, response) {
  var query = new Parse.Query("Review");
  query.equalTo("movie", request.params.movie);
  query.find({
    success: function(results) {
      var sum = 0;
      for (var i = 0; i < results.length; ++i) {
        sum += results[i].get("stars");
      }
      response.success(sum / results.length);
    },
    error: function() {
      response.error("movie lookup failed");
    }
  });
});
The only difference between using averageStars and hello is that we have to provide the parameter that will be accessed in request.params.movie:

curl -X POST \
  -H "X-Parse-Application-Id: EGmUWB7VvrlWfvnjxhC9lBwsoN4FnoMeklYoUJ3H" \
  -H "X-Parse-REST-API-Key: ECQ4ObX9ZHGEnApfT2PJbFuaZmE6ISE2N4hMovta" \
  -H "Content-Type: application/json" \
  -d '{"movie":"The Matrix"}' \
  https://api.parse.com/1/functions/averageStars
Show examples for:  Use keys for:  
In general, two arguments will be passed into cloud functions:

request - The request object contains information about the request. The following fields are set:
params - The parameters object sent to the function by the client.
user - The Parse.User that is making the request. This will not be set if there was no logged-in user.
response - The response object contains two functions:
success - This function takes an optional parameter which is the data to send back to the client. This object can be any JSON object/array and can contain a Parse.Object.
error - If called, signals that there was an error. It takes an optional parameter which will be passed to the client to provide a helpful error message.
If the function is successful, the response in the client looks like:

{
  "result": 4.8
}
If there is an error, the response in the clientlooks like:

{
  "code": 141,
  "error": "movie lookup failed"
}
Running Code When Objects Are Saved

Another reason to run code in the cloud is to enforce a particular data format. For example, you might have both an Android and an iOS app, and you want to validate data for each of those. Rather than writing code once for each client environment, you can write it just once with Cloud Code.

Validations

Let's take a look at our movie review example. When you're choosing how many stars to give something, you can typically only give 1, 2, 3, 4, or 5 stars. You can't give -6 stars or 1337 stars in a review. If we want to reject reviews that are out of bounds, we can do this with the beforeSave method:

Parse.Cloud.beforeSave("Review", function(request, response) {
  if (request.object.get("stars") < 1) {
    response.error("you cannot give less than one star");
  } else if (request.object.get("stars") > 5) {
    response.error("you cannot give more than five stars");
  } else {
    response.success();
  }
});
If response.error is called, the Review object will not get saved, and the client will get an error. If response.success is called, the object will get saved normally. Your code should call one of these two callbacks.

One useful tip is that even if your mobile app has many different versions, the same version of Cloud Code applies to all of them. Thus, if you launch an application that doesn't correctly check the validity of input data, you can still fix this problem by adding a validation with beforeSave.
Modifying Objects On Save

In some cases, you don't want to throw out invalid data. You just want to tweak it a bit before saving it. beforeSave can handle this case, too. You just call response.success on the altered object.

In our movie review example, we might want to ensure that comments aren't too long. A single long comment might be tricky to display. We can use beforeSave to truncate the comment field to 140 characters:

Parse.Cloud.beforeSave("Review", function(request, response) {
  var comment = request.object.get("comment");
  if (comment.length > 140) {
    // Truncate and add a ...
    request.object.set("comment", comment.substring(0, 137) + "...");
  }
  response.success();  
});
Performing Actions After a Save

In some cases, you may want to perform some action, such as a push, after an object has been saved. You can do this with the afterSave method. Let's say you want to keep track of the number of comments on a blog post. you can do that by doing:

Parse.Cloud.afterSave("Comment", function(request) {
  query = new Parse.Object("Post");
  query.get(request.object.post.id, {
    success: function(post) {
      post.increment('comments');
      post.save();
    },
    error: function(error) {
      throw "Got an error " + error.code + " : " + error.message;
    }
  });
});
If the afterSave function fails, the save still returns a successful response to the client. Any errors that occurred while running the afterSave function can be found in the parse log.

Logging from Cloud Code

If you want to log a message to the log files displayed by parse log, you can use console.log, console.error, or console.warn. Both console.error and console.warn will write to the error log.

Parse.Cloud.define("Logger", function(request, response) {
  console.log(request.params);
  response.success();
});
Command Line Tool

We've already seen how Parse's command line tool lets you deploy new code to the cloud. It has several other useful bits of functionality.
Introduction

The same code can be deployed to multiple different applications. This is useful so that you can have separate "development" and "production" applications. Then you test the code on a development application before launching it in production.

The first application that is added (by the new command) will be the default application for all command line operations. All commands except for new take an optional application that the command will be performed on.

Deploying

To deploy a new release, run

$ parse deploy
New release is named v1
This pushes the new code (in cloud/main.js) to the Parse Cloud and deploys this code for the default target which is the first app that was added. You can choose to deploy to a different target by adding the target as an argument to deploy like so:

$ parse deploy "My Other App"
New release is named v2
You can add release notes to the deploy with the -d or --description= option

Add a New Target

You can add a new parse application as a target by running the add command. This prompts you for your Parse.com email and password and provides you a list of applications to choose from:

$ parse add
Email: pirate@gmail.com
Password:
1:PiecesOfEightCounter
2:BootyDivider
Select an App: 1
The add command takes an optional argument which is an alias to assign to the application that can be used instead of the app name.

Typically, all of this configuration data gets stored in the global.json. However, you might have an app that you use for development that you do not want to share with the rest of your team. You can use the --local flag to add this configuration instead to a separate local.json file. This way, you can check global.json into source control, while keeping local.json just on your own machine.
Rolling Back

You can roll back a release using parse rollback. Just like with parse deploy, you can specify an optional target argument.

$ parse rollback
Rolled back to v1
This rollback to the previous version of the code. You can also specify the release name to rollback to by using the -r or --release= option.

Reading the Logs

Every deploy, rollback, and activation of Cloud Code is logged. You can retrieve the end of logs using the parse log command. There are two types of logs:

INFO - contains everything.
ERROR - contains only the errors.
The log command takes an optional target as well as two options:

-n - The number of log lines to display (defaults to 10)
--level/-l - The log level to use (defaults to INFO)
$ parse log -n 1
I2012-07-10:13:37:00] beforeSave handler in release 'v1' ran for GameScore with the input:
  {"original": null, "update":{"score": 1337}}
 and failed validation with Each GamesScore must have a playerName
Listing Releases

You can list the known set of releases on the Parse Cloud with the releases command. Parse only tracks the last 20 releases.

Setting the SDK version

The default Parse JavaScript SDK version that is used for the Cloud Code in this directory is the latest version at the time the new command was run for this directory. If you want to change this, you can change the parseVersion in config/global.json.


the @inlined 
the @tipsymipsy 
a @bklimt 
for @bjacokes 
at @depoll 
with @theunquietone 
then @jamesjyu 
like @hectorramos 
want @ParseIt

JavaScript Guide

If you haven't set up your project yet, please head over to the QuickStart guide to get up and running.

Introduction

The Parse platform provides a complete backend solution for your mobile application. Our goal is to totally eliminate the need for writing server code or maintaining servers.

Our JavaScript SDK is based on the popular Backbone.js framework. It is compatible with existing Backbone applications with minimal changes on your part. Our goal is to minimize configuration and let you quickly start building your JavaScript and HTML5 app on Parse.

Apps

On Parse, you create an App for each of your mobile applications. Each App has its own application id and JavaScript client key that you apply to your web app. Your account on Parse can accommodate multiple Apps. This is useful even if you have one application, since you can deploy different versions for test and production.

Dependencies

Our JavaScript SDK does not require any external libraries. The only exception is the Parse.View class, which requires that you provide jQuery or a jQuery compatible $ method.

Objects

Parse.Object

Storing data on Parse is built around Parse.Object. Each Parse.Object contains key-value pairs of JSON-compatible data. This data is schemaless, which means that you don't need to specify ahead of time what keys exist on each Parse.Object. You simply set whatever key-value pairs you want, and our backend will store it.

For example, let's say you're tracking high scores for a game. A single Parse.Object could contain:

score: 1337, playerName: "Sean Plott", cheatMode: false
Keys must be alphanumeric strings. Values can be strings, numbers, booleans, or even arrays and dictionaries - anything that can be JSON-encoded.

Each Parse.Object is an instance of a specific subclass with a class name that you can use to distinguish different sorts of data. For example, we could call the high score object a GameScore. We recommend that you NameYourClassesLikeThis and nameYourKeysLikeThis, just to keep your code looking pretty.

To create a new subclass, use the Parse.Object.extend method. Any Parse.Query will return instances of the new class for any Parse.Object with the same classname. If you're familiar with Backbone.Model, then you already know how to use Parse.Object. It's designed to be a drop-in replacement.

// Simple syntax to create a new subclass of Parse.Object.
var GameScore = Parse.Object.extend("GameScore");
 
// Create a new instance of that class.
var gameScore = new GameScore();
 
// Alternatively, you can use the typical Backbone syntax.
var Achievement = Parse.Object.extend({
  className: "Achievement"
});
You can add additional methods to your subclasses of Parse.Object.

// A complex subclass of Parse.Object
var Monster = Parse.Object.extend("Monster", {
  // Instance methods
  hasSuperHumanStrength: function() {
    return this.get("strength") > 18;
  }
}, {
  // Class methods
  spawn: function(strength) {
    var monster = new Monster();
    monster.set("strength", strength);
    return monster;
  }
});
 
var monster = Monster.spawn(200);
alert(monster.strength());  // Displays 200.
Saving Objects

Let's say you want to save the GameScore described above to the Parse Cloud. The interface is similar to a Backbone.Model, including the save method:

var GameScore = Parse.Object.extend("GameScore");
var gameScore = new GameScore();
 
gameScore.set("score", 1337);
gameScore.set("playerName", "Sean Plott");
gameScore.set("cheatMode", false);
 
gameScore.save(null, {
  success: function(gameScore) {
    // The object was saved successfully.
  },
  error: function(gameScore, error) {
    // The save failed.
    // error is a Parse.Error with an error code and description.
  }
});
After this code runs, you will probably be wondering if anything really happened. To make sure the data was saved, you can look at the Data Browser in your app on Parse. You should see something like this:

objectId: "xWMyZ4YEGZ", score: 1337, playerName: "Sean Plott", cheatMode: false,
createdAt:"2011-06-10T18:33:42Z", updatedAt:"2011-06-10T18:33:42Z"
There are two things to note here. You didn't have to configure or set up a new Class called GameScore before running this code. Your Parse app lazily creates this Class for you when it first encounters it.

There are also a few fields you don't need to specify that are provided as a convenience. objectId is a unique identifier for each saved object. createdAt and updatedAt represent the time that each object was created and last modified in the cloud. Each of these fields is filled in by Parse, so they don't exist on a Parse.Object until a save operation has completed.

If you prefer, you can set attributes directly in your call to save instead.

var GameScore = Parse.Object.extend("GameScore");
var gameScore = new GameScore();
 
gameScore.save({
  score: 1337,
  playerName: "Sean Plott",
  cheatMode: false
}, {
  success: function(gameScore) {
    // The object was saved successfully.
  },
  error: function(gameScore, error) {
    // The save failed.
    // error is a Parse.Error with an error code and description.
  }
});
Retrieving Objects

Saving data to the cloud is fun, but it's even more fun to get that data out again. If you have the objectId, you can retrieve the whole Parse.Object using a Parse.Query:

var GameScore = Parse.Object.extend("GameScore");
var query = new Parse.Query(GameScore);
query.get("xWMyZ4YEGZ", {
  success: function(gameScore) {
    // The object was retrieved successfully.
  },
  error: function(object, error) {
    // The object was not retrieved successfully.
    // error is a Parse.Error with an error code and description.
  }
});
To get the values out of the Parse.Object, use the get method.

var score = gameScore.get("score");
var playerName = gameScore.get("playerName");
var cheatMode = gameScore.get("cheatMode");
The three special values are provided as properties:

var objectId = gameScore.id;
var updatedAt = gameScore.updatedAt;
var createdAt = gameScore.createdAt;
If you need to refresh an object you already have with the latest data that is in the Parse Cloud, you can call the fetch method like so:

myObject.fetch({
  success: function(myObject) {
    // The object was refreshed successfully.
  },
  error: function(myObject, error) {
    // The object was not refreshed successfully.
    // error is a Parse.Error with an error code and description.
  }
});
Updating Objects

Updating an object is simple. Just set some new data on it and call one the save method. For example:

// Create the object.
var GameScore = Parse.Object.extend("GameScore");
var gameScore = new GameScore();
 
gameScore.set("score", 1337);
gameScore.set("playerName", "Sean Plott");
gameScore.set("cheatMode", false);
gameScore.set("skills", ["pwnage", "flying"]);
 
gameScore.save(null, {
  success: function(gameScore) {
    // Now let's update it with some new data. In this case, only cheatMode and score
    // will get sent to the cloud. playerName hasn't changed.
    gameScore.set("cheatMode", true);
    gameScore.set("score", 1338);
    gameScore.save();
  }
});
Parse automatically figures out which data has changed so only "dirty" fields will be sent to the Parse Cloud. You don't need to worry about squashing data that you didn't intend to update.

Counters

The above example contains a common use case. The "score" field is a counter that we'll need to continually update with the player's latest score. Using the above method works but it's cumbersome and can lead to problems if you have multiple clients trying to update the same counter.

To help with storing counter-type data, Parse provides methods that atomically increment (or decrement) any number field. So, the same update can be rewritten as:

gameScore.increment("score");
gameScore.save();
You can also increment by any amount by passing in a second argument to increment. When no amount is specified, 1 is used by default.

Arrays

To help with storing array data, there are three operations that can be used to atomically change an array associated with a given key:

add append the given object to the end of an array field.
addUnique add the given object only if it isn't already contained in an array field. The position of the insert is not guaranteed.
remove remove all instances of the given object from an array field.
For example, we can add items to the set-like "skills" field like so:

gameScore.addUnique("skills", "flying");
gameScore.addUnique("skills", "kungfu");
gameScore.save();
Destroying Objects

To delete an object from the cloud:

myObject.destroy({
  success: function(myObject) {
    // The object was deleted from the Parse Cloud.
  },
  error: function(myObject, error) {
    // The delete failed.
    // error is a Parse.Error with an error code and description.
  }
});
You can delete a single field from an object with the unset method:

// After this, the playerName field will be empty
myObject.unset("playerName");
 
// Saves the field deletion to the Parse Cloud
myObject.save();
Relational Data

Objects can have relationships with other objects. To model this behavior, any Parse.Object can be used as a value in other Parse.Objects. Internally, the Parse framework will store the referred-to object in just one place, to maintain consistency.

For example, each Comment in a blogging app might correspond to one Post. To create a new Post with a single Comment, you could write:

// Declare the types.
var Post = Parse.Object.extend("Post");
var Comment = Parse.Object.extend("Comment");
 
// Create the post
 
var myPost = new Post();
myPost.set("title", "I'm Hungry");
myPost.set("content", "Where should we go for lunch?");
 
// Create the comment
var myComment = new Comment();
myComment.set("content", "Let's do Sushirrito.");
 
// Add a relation between the Post and Comment
myComment.set("parent", myPost);
 
// This will save both myPost and myComment
myComment.save();
You can also link objects using just their objectIds like so:

var post = new Post();
post.id = "1zEcyElZ80";
 
myComment.set("parent", post);
By default, when fetching an object, related Parse.Objects are not fetched. These objects' values cannot be retrieved until they have been fetched like so:

var post = fetchedComment.get("parent");
post.fetch({
  success: function(post) {
    var title = post.get("title");
  }
});
You can also model many-to-many relationships using Parse.Relation. This works similar to storing an array of Parse.Objects in a key, except that you don't need to fetch all of the objects in a relation at once. This allows Parse.Relation to scale to many more objects than the array of Parse.Object approach. For example, a User may have many Posts that they might like. In this case, you can store the set of Posts that a User likes using relation. In order to add a post to a list, you can do:

var user = Parse.User.current();
var relation = user.relation("likes");
relation.add(post);
user.save();
You can remove a post from a Parse.Relation with something like:

relation.remove(post);
By default, the list of objects in this relation are not downloaded. You can get a list of the posts that a user likes by using the Parse.Query returned by query. The code looks like:

relation.query().find({
  success: function(list) {
    // list contains the posts that the current user likes.
  }
});
If you want only a subset of the Posts, you can add extra constraints to the Parse.Query returned by query like this:

var query = relation.query();
query.equalTo("title", "I'm Hungry");
query.find({
  success:function(list) {
    // list contains post liked by the current user which have the title "I'm Hungry".
  }
});
For more details on Parse.Query, please look at the query portion of this guide. A Parse.Relation behaves similar to an array of Parse.Object for querying purposes, so any query you can do on an array of objects, you can do on a Parse.Relation.

Data Types

So far we've used values with type String, Number, and Parse.Object. Parse also supports JavaScript Dates and null.

You can nest JavaScript Objects and JavaScript Arrays to store more structured data within a single Parse.Object.

Some examples:

var number = 42;
var string = "the number is " + number;
var date = new Date();
var array = [string, number];
var object = { number: number, string: string };
 
var BigObject = Parse.Object.extend("BigObject");
var bigObject = new BigObject();
bigObject.set("myNumber", number);
bigObject.set("myString", string);
bigObject.set("myDate", date);
bigObject.set("myArray", array);
bigObject.set("myObject", object);
bigObject.set("myNull", null);
bigObject.save();
Parse.Objects should not exceed 128 kilobytes in size.

For more information about how Parse handles data, check out our documentation on Data & Security.

Queries

We've already seen how a Parse.Query with get can retrieve a single Parse.Object from Parse. There are many other ways to retrieve data with Parse.Query - you can retrieve many objects at once, put conditions on the objects you wish to retrieve, and more.
Basic Queries

In many cases, get isn't powerful enough to specify which objects you want to retrieve. Parse.Query offers different ways to retrieve a list of objects rather than just a single object.

The general pattern is to create a Parse.Query, put conditions on it, and then retrieve an Array of matching Parse.Objects using find. For example, to retrieve of the scores with a particular playerName, use the equalTo method to constrain the value for a key.

var GameScore = Parse.Object.extend("GameScore");
var query = new Parse.Query(GameScore);
query.equalTo("playerName", "Dan Stemkoski");
query.find({
  success: function(results) {
    alert("Successfully retrieved " + results.length + " scores.");
  },
  error: function(error) {
    alert("Error: " + error.code + " " + error.message);
  }
});
Query Constraints

There are several ways to put constraints on the objects found by a Parse.Query. You can filter out objects with a particular key-value pair with whereKey:notEqualTo:

query.notEqualTo("playerName", "Michael Yabuti");
You can give multiple constraints, and objects will only be in the results if they match all of the constraints. In other words, it's like an AND of constraints.

query.notEqualTo("playerName", "Michael Yabuti");
query.greaterThan("playerAge", 18);
You can limit the number of results by setting limit. By default, results are limited to 100, but anything from 1 to 1000 is a valid limit:

query.limit(10); // limit to at most 10 results
If you want exactly one result, a more convenient alternative may be to use first instead of using find.

var GameScore = Parse.Object.extend("GameScore");
var query = new Parse.Query(GameScore);
query.equalTo("playerEmail", "dstemkoski@example.com");
query.first({
  success: function(object) {
    // Successfully retrieved the object.
  },
  error: function(error) {
    alert("Error: " + error.code + " " + error.message);
  }
});
You can skip the first results by setting skip. This can be useful for pagination:

query.skip(10); // skip the first 10 results
For sortable types like numbers and strings, you can control the order in which results are returned:

// Sorts the results in ascending order by the score field
query.ascending("score");
 
// Sorts the results in descending order by the score field
query.descending("score");
For sortable types, you can also use comparisons in queries:

// Restricts to wins < 50
query.lessThan("wins", 50);
 
// Restricts to wins <= 50
query.lessThanOrEqualTo("wins", 50);
 
// Restricts to wins > 50
query.greaterThan("wins", 50);
 
// Restricts to wins >= 50
query.greaterThanOrEqualTo("wins", 50);
If you want to retrieve objects matching several different values, you can use containedIn, providing an array of acceptable values. This is often useful to replace multiple queries with a single query. For example, if you want to retrieve scores made by any player in a particular list:

// Finds scores from any of Jonathan, Dario, or Shawn
query.containedIn("playerName",
                  ["Jonathan Walsh", "Dario Wunsch", "Shawn Simon"]);
If you want to retrieve objects that do not match any of several values you can use notContainedIn, providing an array of acceptable values. For example if you want to retrieve scores from players besides those in a list:

// Finds scores from anyone who is neither Jonathan, Dario, nor Shawn
query.notContainedIn("playerName",
                     ["Jonathan Walsh", "Dario Wunsch", "Shawn Simon"]);
If you want to retrieve objects that have a particular key set, you can use exists. Conversely, if you want to retrieve objects without a particular key set, you can use doesNotExist.

// Finds objects that have the score set
query.exists("score");
 
// Finds objects that don't have the score set
query.doesNotExist("score");
You can use the matchesKeyInQuery method to get objects where a key matches the value of a key in a set of objects resulting from another query. For example, if you have a class containing sports teams and you store a user's hometown in the user class, you can issue one query to find the list of users whose hometown teams have winning records. The query would look like:

var Team = Parse.Object.extend("Team");
var teamQuery = new Parse.Query(Team);
teamQuery.greaterThan("winPct", 0.5);
var userQuery = new Parse.Query(Parse.User);
userQuery.matchesKeyInQuery("hometown", "city", teamQuery);
userQuery.find({ 
  success: function(results) {
    // results has the list of users with a hometown team with a winning record
  }
});
Queries on Array Values

For keys with an array type, you can find objects where the key's array value contains 2 by:

// Find objects where the array in arrayKey contains 2.
query.equalTo("arrayKey", 2);
Queries on String Values

There are several ways you can search over values containing strings. For any regular expression, you can use matches to retrieve only the values that match it:

// Finds barbecue sauces that start with a capital letter and a digit.
var BarbecueSauce = Parse.Object.extend("BarbecueSauce");
var query = new Parse.Query(BarbecueSauce);
query.matches("name", /^[A-Z][0-9]/);
 
query.find({
  success: function(sauces) {
    // The sauces could have, for example, name = "A1 Steak Sauce"
  }
});
Parse uses the Perl-compatible regular expression format.

Parse.Query also supports modifiers with matches. The supported PCRE modifiers are:
i - Case insensitive search
m - Search across multiple lines of input
// Some people type "BBQ", others type "bbq". Consider them the same thing with the i modifier.
// The m modifier helps us find sauces that call themselves "bbq sauce" after the first line of text.
var query = new Parse.Query(BarbecueSauce);
query.matches("description", "bbq", "im");
 
query.find({
  success: function(sauces) {
    // Sauces that call themselves a "bbq" sauce.
  }
});
There are also several helper functions for standard string operations: substrings, prefixes, and suffixes. Use contains to restrict to string values containing a substring:

// Finds barbecue sauces that contain the string "Extra Spicy!".
var query = new Parse.Query(BarbecueSauce);
query.contains("name", "Extra Spicy!");
Use startsWith to restrict to string values that start with a particular string. Similar to a MySQL LIKE operator, this is indexed so it is efficient for large datasets:

// Finds barbecue sauces that start with "Big Daddy's".
var query = new Parse.Query(BarbecueSauce);
query.startsWith("name", "Big Daddy's");
Use endsWith to restrict to string values that end with a particular string:

// Finds barbecue sauces that end with "Original Recipe".
var query = new Parse.Query(BarbecueSauce);
query.endsWith("Original Recipe");
Relational Queries

There are several ways to issue queries for relational data. If you want to retrieve objects where a field matches a particular Parse.Object, you can use equalTo just like for other data types. For example, if each Comment has a Post object in its post field, you can fetch comments for a particular Post:

// Assume Parse.Object myPost was previously created.
var query = new Parse.Query(Comment);
query.equalTo("post", myPost);
query.find({
  success: function(comments) {
    // comments now contains the comments for myPost
  }
});
If you want to retrieve objects where a field contains a Parse.Object that matches a different query, you can use matchesQuery. Note that the default limit of 100 and maximum limit of 1000 apply to the inner query as well, so with large data sets you may need to construct queries carefully to get the desired behavior. In order to find comments for posts containing images, you can do:

var Post = Parse.Object.extend("Post");
var Comment = Parse.Object.extend("Comment");
var innerQuery = new Parse.Query(Post);
innerQuery.exists("image");
var query = new Parse.Query(Comment);
query.matchesQuery("post", innerQuery);
query.find({
  success: function(comments) {
    // comments now contains the comments for posts with images.
  }
});
If you want to retrieve objects where a field contains a Parse.Object that does not match a different query, you can use doesNotMatchQuery. In order to find comments for posts without images, you can do:

var Post = Parse.Object.extend("Post");
var Comment = Parse.Object.extend("Comment");
var innerQuery = new Parse.Query(Post);
innerQuery.exists("image");
var query = new Parse.Query(Comment);
query.doesNotMatchQuery("post", innerQuery);
query.find({
  success: function(comments) {
    // comments now contains the comments for posts without images.
  }
});
You can also do relational queries by objectId:

var post = new Post();
post.id = "1zEcyElZ80";
query.equalTo("post", post);
In some situations, you want to return multiple types of related objects in one query. You can do this with the include method. For example, let's say you are retrieving the last ten comments, and you want to retrieve their related posts at the same time:

var query = new Parse.Query(Comment);
 
// Retrieve the most recent ones
query.descending("createdAt");
 
// Only retrieve the last ten
query.limit(10);
 
// Include the post data with each comment
query.include("post");
 
query.find({
  success: function(comments) {
    // Comments now contains the last ten comments, and the "post" field
    // has been populated. For example:
    for (var i = 0; i < comments.length; i++) {
      // This does not require a network access.
      var post = comments[i].get("post");
    }
  }
});
You can also do multi level includes using dot notation. If you wanted to include the post for a comment and the post's author as well you can do:

query.include(["post.author"]);
You can issue a query with multiple fields included by calling include multiple times. This functionality also works with Parse.Query helpers like first and get.

Counting Objects

If you just need to count how many objects match a query, but you do not need to retrieve all the objects that match, you can use count instead of find. For example, to count how many games have been played by a particular player:

var GameScore = Parse.Object.extend("GameScore");
var query = new Parse.Query(GameScore);
query.equalTo("playerName", "Sean Plott");
query.count({
  success: function(count) {
    // The count request succeeded. Show the count
    alert("Sean has played " + count + " games");
  },
  error: function(error) {
    // The request failed
  }
});
Compound Queries

If you want to find objects that match one of several queries, you can use Parse.Query.or method to construct a query that is an OR of the queries passed in. For instance if you want to find players who either have a lot of wins or a few wins, you can do:

var lotsOfWins = new Parse.Query("Player");
lotsOfWins.greaterThan(150);
 
var fewWins = new Parse.Query("Player");
fewWins.lessThan(5);
 
var mainQuery = Parse.Query.or(lotsOfWins, fewWins);
mainQuery.find({
  success: function(results) {
     // results contains a list of players that either have won a lot of games or won only a few games.
  },
  error: function(error) {
    // There was an error.
  }
});
You can also add more constraints to the newly constructed Parse.Query which act as an 'and' operator.

Collections

A Parse.Collection is an ordered set of Parse.Objects. It is compatible with Backbone.Collection, and has all the same functionality. You can create a new subclass using either a model class, or a particular Parse.Query.

// A Collection containing all instances of TestObject.
var TestCollection = Parse.Collection.extend({
  model: TestObject
});
var collection = new TestCollection();
 
// A Collection of TestObjects whose temperature is "hot".
var HotCollection = Parse.Collection.extend({
  model: TestObject,
  query: (new Parse.Query(TestObject)).equalTo("temperature", "hot")
});
var collection = new HotCollection();
 
// The Collection of TestObjects that match a complex query.
var query = new Parse.Query(TestObject);
query.equalTo("temperature", "hot");
query.greaterThan("degreesF", 100);
var collection = query.collection();
Retrieving Collections

To load all of the items in the collection, use the fetch method.

var collection = new TestCollection();
collection.fetch({
  success: function(collection) {
    collection.each(function(object) {
      console.warn(object);
    });
  },
  error: function(collection, error) {
    // The collection could not be retrieved.
  }
});
Sorting Collections

You can keep all the items in a collection in a sorted order by setting a comparator.

var collection = new TestCollection();
collection.comparator = function(object) {
  return object.get("temperature");
};
Modifying a Collection

Collections are mutable. You can access all the items, and add or remove items.

var collection = new TestCollection();
 
collection.add([
  {"name": "Duke"},
  {"name": "Scarlett"}
]);
 
// Get the "Duke" Parse.Object by its sorted position.
var model = collection.at(0);
 
// Or you can get it by Parse objectId.
var modelAgain = collection.get(model.id);
 
// Remove "Duke" from the collection.
collection.remove(model);
 
// Completely replace all items in the collection.
collection.reset([
  {"name": "Hawk"},
  {"name": "Jane"}
]);
Users

At the core of many apps, there is a notion of user accounts that lets users access their information in a secure manner. We provide a specialized user class called Parse.User that automatically handles much of the functionality required for user account management.

With this class, you'll be able to add user account functionality in your app.

Parse.User is a subclass of Parse.Object, and has all the same features, such as flexible schema, automatic persistence, and a key value interface. All the methods that are on Parse.Object also exist in Parse.User. The difference is that Parse.User has some special additions specific to user accounts.

Properties

Parse.User has several values that set it apart from Parse.Object:

username: The username for the user (required).
password: The password for the user (required on signup).
email: The email address for the user (optional).
We'll go through each of these in detail as we run through the various use cases for users.

Signing Up

The first thing your app will do is probably ask the user to sign up. The following code illustrates a typical sign up:

var user = new Parse.User();
user.set("username", "my name");
user.set("password", "my pass");
user.set("email", "email@example.com");
 
// other fields can be set just like with Parse.Object
user.set("phone", "415-392-0202");
 
user.signUp(null, {
  success: function(user) {
    // Hooray! Let them use the app now.
  },
  error: function(user, error) {
    // Show the error message somewhere and let the user try again.
    alert("Error: " + error.code + " " + error.message);
  }
});
This call will asynchronously create a new user in your Parse App. Before it does this, it also checks to make sure that both the username and email are unique. Also, it securely hashes the password in the cloud. We never store passwords in plaintext, nor will we ever transmit passwords back to the client in plaintext.

Note that we used the signUp method, not the save method. New Parse.Users should always be created using the signUp method. Subsequent updates to a user can be done by calling save.

If a signup isn't successful, you should read the error object that is returned. The most likely case is that the username or email has already been taken by another user. You should clearly communicate this to your users, and ask them try a different username.

You are free to use an email address as the username. Simply ask your users to enter their email, but fill it in the username property — Parse.User will work as normal. We'll go over how this is handled in the reset password section.

Logging In

Of course, after you allow users to sign up, you need to let them log in to their account in the future. To do this, you can use the class method logIn.

Parse.User.logIn("myname", "mypass", {
  success: function(user) {
    // Do stuff after successful login.
  },
  error: function(user, error) {
    // The login failed. Check error to see why.
  }
});
Verifying Emails

Enabling email verification in an application's settings allows the application to reserve part of its experience for users with confirmed email addresses. Email verification adds the emailVerified key to the Parse.User object. When a Parse.User's email is set or modified, emailVerified is set to false. Parse then emails the user a link which will set emailVerified to true.

There are three emailVerified states to consider:

true - the user confirmed his or her email address by clicking on the link Parse emailed them. Parse.Users can never have a true value when the user account is first created.
false - at the time the Parse.User object was last refreshed, the user had not confirmed his or her email address. If emailVerified is false, consider calling fetch on the Parse.User.
missing - the Parse.User was created when email verification was off or the Parse.User does not have an email.
Current User

It would be bothersome if the user had to log in every time they open your app. You can avoid this by using the cached current Parse.User object.

Whenever you use any signup or login methods, the user is cached in localStorage. You can treat this cache as a session, and automatically assume the user is logged in:

var currentUser = Parse.User.current();
if (currentUser) {
    // do stuff with the user
} else {
    // show the signup or login page
}
You can clear the current user by logging them out:

Parse.User.logOut();
 
var currentUser = Parse.User.current();  // this will now be null
Security For User Objects

The Parse.User class is secured by default. Data stored in a Parse.User can only be modified by that user. By default, the data can still be read by any client. Thus, some Parse.User objects are authenticated and can be modified, whereas others are read-only.

Specifically, you are not able to invoke any of the save or delete methods unless the Parse.User was obtained using an authenticated method, like logIn or signUp. This ensures that only the user can alter their own data.

The following illustrates this security policy:

var user = Parse.User.logIn("my_username", "my_password", {
  success: function(user) {
    user.set("username", "my_new_username");  // attempt to change username
    user.save(null, {
      success: function(user) {
        // This succeeds, since the user was authenticated on the device
 
        // Get the user from a non-authenticated method
        var query = new Parse.Query(Parse.User);
        query.get(user.objectId, {
          success: function(userAgain) {
            userAgain.set("username", "another_username");
            userAgain.save(null, {
              error: function(userAgain, error) {
                // This will error, since the Parse.User is not authenticated
              }
            });
          }
        });
      }
    });
  }
});
The Parse.User obtained from Parse.User.current() will always be authenticated.

If you need to check if a Parse.User is authenticated, you can invoke the authenticated method. You do not need to check authenticated with Parse.User objects that are obtained via an authenticated method.

Security For Other Objects

The same security model that applies to the Parse.User can be applied to other objects. For any object, you can specify which users are allowed to read the object, and which users are allowed to modify an object. To support this type of security, each object has an access control list, implemented by the Parse.ACL class.

The simplest way to use a Parse.ACL is to specify that an object may only be read or written by a single user. To create such an object, there must first be a logged in Parse.User. Then, new Parse.ACL(user) generates a Parse.ACL that limits access to that user. An object's ACL is updated when the object is saved, like any other property. Thus, to create a private note that can only be accessed by the current user:

var Note = Parse.Object.extend("Note");
var privateNote = new Note();
privateNote.set("content", "This note is private!");
privateNote.setACL(new Parse.ACL(Parse.User.current()));
privateNote.save();
This note will then only be accessible to the current user, although it will be accessible to any device where that user is signed in. This functionality is useful for applications where you want to enable access to user data across multiple devices, like a personal todo list.

Permissions can also be granted on a per-user basis. You can add permissions individually to a Parse.ACL using setReadAccess and setWriteAccess. For example, let's say you have a message that will be sent to a group of several users, where each of them have the rights to read and delete that message:

var Message = Parse.Object.extend("Message");
var groupMessage = new Message();
var groupACL = new Parse.ACL();
 
// userList is an array with the users we are sending this message to.
for (var i = 0; i < userList.length; i++) {
  groupACL.setReadAccess(userList[i], true);
  groupACL.setWriteAccess(userList[i], true);
}
 
groupMessage.setACL(groupACL);
groupMessage.save();
You can also grant permissions to all users at once using setPublicReadAccess and setPublicWriteAccess. This allows patterns like posting comments on a message board. For example, to create a post that can only be edited by its author, but can be read by anyone:

var publicPost = new Post();
var postACL = new Parse.ACL(Parse.User.current());
postACL.setPublicReadAccess(true);
publicPost.setACL(postACL);
publicPost.save();
Operations that are forbidden, such as deleting an object that you do not have write access to, result in a Parse.Error.OBJECT_NOT_FOUND error code. For security purposes, this prevents clients from distinguishing which object ids exist but are secured, versus which object ids do not exist at all.

Resetting Passwords

It's a fact that as soon as you introduce passwords into a system, users will forget them. In such cases, our library provides a way to let them securely reset their password.

To kick off the password reset flow, ask the user for their email address, and call:

Parse.User.requestPasswordReset("email@example.com", {
  success: function() {
    // Password reset request was sent successfully
  },
  error: function(error) {
    // Show the error message somewhere
    alert("Error: " + error.code + " " + error.message);
  }
});
This will attempt to match the given email with the user's email or username field, and will send them a password reset email. By doing this, you can opt to have users use their email as their username, or you can collect it separately and store it in the email field.

The flow for password reset is as follows:

User requests that their password be reset by typing in their email.
Parse sends an email to their address, with a special password reset link.
User clicks on the reset link, and is directed to a special Parse page that will allow them type in a new password.
User types in a new password. Their password has now been reset to a value they specify.
Note that the messaging in this flow will reference your app by the name that you specified when you created this app on Parse.

Querying

To query for users, you can simple create a new Parse.Query for Parse.Users:

var query = new Parse.Query(Parse.User);
query.equalTo(gender, "female");  // find all the women
query.find({
  success: function(women) {
    // Do stuff
  }
});
Associations

Associations involving a Parse.User work right of the box. For example, let's say you're making a blogging app. To store a new post for a user and retrieve all their posts:

var user = Parse.User.current();
 
// Make a new post
var Post = Parse.Object.extend("Post");
var post = new Post();
post.set("title", "My New Post");
post.set("body", "This is some great content.");
post.set("user", user);
post.save(null, {
  success: function(post) {
    // Find all posts by the current user
    var query = new Parse.Query(Post);
    query.equalTo("user", user);
    query.find({
      success: function(usersPosts) {
        // userPosts contains all of the posts by the current user.
      }
    });
  }
});
Users in the Data Browser

The User class is a special class that is dedicated to storing Parse.User objects. In the data browser, you'll see a little person icon next to the User class:



Roles

As your app grows in scope and user-base, you may find yourself needing more coarse-grained control over access to pieces of your data than user-linked ACLs can provide. To address this requirement, Parse supports a form of Role-based Access Control. Roles provide a logical way of grouping users with common access privileges to your Parse data. Roles are named objects that contain users and other roles. Any permission granted to a role is implicitly granted to its users as well as to the users of any roles that it contains.

For example, in your application with curated content, you may have a number of users that are considered "Moderators" and can modify and delete content created by other users. You may also have a set of users that are "Administrators" and are allowed all of the same privileges as Moderators, but can also modify the global settings for the application. By adding users to these roles, you can ensure that new users can be made moderators or administrators, without having to manually grant permission to every resource for each user.

We provide a specialized class called Parse.Role that represents these role objects in your client code. Parse.Role is a subclass of Parse.Object, and has all of the same features, such as a flexible schema, automatic persistence, and a key value interface. All the methods that are on Parse.Object also exist on Parse.Role. The difference is that Parse.Role has some additions specific to management of roles.

Properties

Parse.Role has several properties that set it apart from Parse.Object:

name: The name for the role. This value is required, and can only be set once as a role is being created. The name must consist of alphanumeric characters, spaces, -, or _. This name will be used to identify the Role without needing its objectId.
users: A relation to the set of users that will inherit permissions granted to the containing role.
roles: A relation to the set of roles whose users and roles will inherit permissions granted to the containing role.
Security for Role Objects

The Parse.Role uses the same security scheme (ACLs) as all other objects on Parse, except that it requires an ACL to be set explicitly. Generally, only users with greatly elevated privileges (e.g. a master user or Administrator) should be able to create or modify a Role, so you should define its ACLs accordingly. Remember, if you give write-access to a Parse.Role to a user, that user can add other users to the role, or even delete the role altogether.

To create a new Parse.Role, you would write:

// By specifying no write privileges for the ACL, we can ensure the role cannot be altered.
var roleACL = new Parse.ACL();
roleACL.setPublicReadAccess(true);
var role = new Parse.Role("Administrator", roleACL);
role.save();
You can add users and roles that should inherit your new role's permissions through the "users" and "roles" relations on Parse.Role:

var role = new Parse.Role(roleName, roleACL);
for (var i = 0; i < usersToAddToRole.length; i++) {
  role.getUsers().add(usersToAddToRole[i]);
}
for (var i = 0; i < rolesToAddToRole.length; i++) {
  role.getRoles().add(rolesToAddToRole[i]);
}
role.save();
Take great care when assigning ACLs to your roles so that they can only be modified by those who should have permissions to modify them.

Security for Other Objects

Now that you have created a set of roles for use in your application, you can use them with ACLs to define the privileges that their users will receive. Each Parse.Object can specify a Parse.ACL, which provides an access control list that indicates which users and roles should be granted read or write access to the object.

Giving a role read or write permission to an object is straightforward. You can either use the Parse.Role:

var moderators = /* Query for some Parse.Role */;
var wallPost = new Parse.Object("WallPost");
var postACL = new Parse.ACL();
postACL.setRoleWriteAccess(moderators);
wallPost.setACL(postACL);
wallPost.save();
You can avoid querying for a role by specifying its name for the ACL:

var wallPost = new ParseObject("WallPost");
car postACL = new ParseACL();
postACL.setRoleWriteAccess("Moderators", true);
wallPost.setACL(postACL);
wallPost.save();
Role Hierarchy

As described above, one role can contain another, establishing a parent-child relationship between the two roles. The consequence of this relationship is that any permission granted to the parent role is implicitly granted to all of its child roles.

These types of relationships are commonly found in applications with user-managed content, such as forums. Some small subset of users are "Administrators", with the highest level of access to tweaking the application's settings, creating new forums, setting global messages, and so on. Another set of users are "Moderators", who are responsible for ensuring that the content created by users remains appropriate. Any user with Administrator privileges should also be granted the permissions of any Moderator. To establish this relationship, you would make your "Administrators" role a child role of "Moderators", like this:

var administrators = /* Your "Administrators" role */;
var moderators = /* Your "Moderators" role */;
moderators.getRoles().add(administrators);
moderators.save();
Role Quotas

Role-based access control is a premium feature of the Parse platform. If you are on the "Basic" plan are limited to 1 custom role, which you can use to protect access for most basic applications that need broader security groups. Parse will not allow you to exceed this quota by accident, preventing you from creating new Roles until you upgrade your plan.

If your current plan is "Pro" or above, you will have an allotment of roles included with your package, and creating Roles exceeding this quota will result in additional charges.

For more information, please see our Plans page.

Facebook Users

Parse provides an easy way to integrate Facebook with your application. The Parse.FacebookUtils class integrates Parse.User and the Facebook Javascript SDK to make linking your users to their Facebook identities easy.

Using our Facebook integration, you can associate an authenticated Facebook user with a Parse.User. With just a few lines of code, you'll be able to provide a "log in with Facebook" option in your app, and be able to save their data to Parse.

Setup

To start using Facebook with Parse, you need to:

Set up a Facebook app, if you haven't already. Choose the "Website with Facebook Login" option under "Select how your app integrates with Facebook" and enter your site's URL.
Add your application's Facebook Application ID on your Parse application's settings page.
Follow these instructions for loading the Facebook Javascript SDK into your application.
Replace your call to FB.init() with a call to Parse.FacebookUtils.init(). For example, if you loaded the Facebook SDK asynchronously, your fbAsyncInit function will look like this:
window.fbAsyncInit = function() {
  Parse.FacebookUtils.init({
    appId      : 'YOUR_APP_ID', // Facebook App ID
    channelUrl : '//WWW.YOUR_DOMAIN.COM/channel.html', // Channel File
    status     : true, // check login status
    cookie     : true, // enable cookies to allow Parse to access the session
    xfbml      : true  // parse XFBML
  });
 
  // Additional initialization code here
};
If you encounter any issues that are Facebook-related, a good resource is the official getting started guide from Facebook.

There are two main ways to use Facebook with your Parse users: (1) logging in as a Facebook user and creating a Parse.User, or (2) linking Facebook to an existing Parse.User.

Login & Signup

Parse.FacebookUtils provides a way to allow your Parse.Users to log in or sign up through Facebook. This is accomplished using the logIn() method:

Parse.FacebookUtils.logIn(null, {
  success: function(user) {
    if (!user.existed()) {
      alert("User signed up and logged in through Facebook!");
    } else {
      alert("User logged in through Facebook!");
    }
  },
  error: function(user, error) {
    alert("User cancelled the Facebook login or did not fully authorize.");
  }
});
When this code is run, the following happens:

The user is shown the Facebook login dialog.
The user authenticates via Facebook, and your app receives a callback.
Our SDK receives the Facebook data and saves it to a Parse.User. If it's a new user based on the Facebook ID, then that user is created.
Your success callback is called with the user.
You may optionally provide a comma-delimited string that specifies what permissions your app requires from the Facebook user. For example:

Parse.FacebookUtils.logIn("user_likes,email", {
  success: function(user) {
    // Handle successful login
  },
  error: function(user, error) {
    // Handle errors and cancellation
  }
});
Parse.User integration doesn't require any permissions to work out of the box (ie. null or specifying no permissions is perfectly acceptable). Read more about permissions on Facebook's developer guide.

It is up to you to record any data that you need from the Facebook user after they authenticate. To accomplish this, you'll need to do a graph query via Facebook's SDK.
Linking

If you want to associate an existing Parse.User to a Facebook account, you can link it like so:

if (!Parse.FacebookUtils.isLinked(user)) {
  Parse.FacebookUtils.link(user, null, {
    success: function(user) {
      alert("Woohoo, user logged in with Facebook!");
    },
    error: function(user, error) {
      alert("User cancelled the Facebook login or did not fully authorize.");
    }
  });
}
The steps that happen when linking are very similar to log in. The difference is that on successful login, the existing Pars.eUser is updated with the Facebook information. Future logins via Facebook will now log the user into their existing account.

If you want to unlink Facebook from a user, simply do this:

Parse.FacebookUtils.unlink(user, {
  success: function(user) {
    alert("The user is no longer associated with their Facebook account.");
  }
});
Facebook SDK and Parse

The Facebook Javascript SDK provides a main FB object that is the starting point for many of the interactions with Facebook's API. You can read more about their SDK here.

Facebook login using the Parse SDK requires that the Facebook SDK already be loaded before calling Parse.FacebookUtils.init().

Our library manages the FB object for you. The FB singleton is synchronized with the current user by default, so any methods you call on it will be acting on the Facebook user associated with the current Parse.User. Calling FB.login() or FB.logOut() explicitly will cause the Parse.User and FB object to fall out of synchronization, and is not recommended.

GeoPoints

Parse allows you to associate real-world latitude and longitude coordinates with an object. Adding a Parse.GeoPoint to a Parse.Object allows queries to take into account the proximity of an object to a reference point. This allows you to easily do things like find out what user is closest to another user or which places are closest to a user.

Parse.GeoPoint

To associate a point with an object you first need to create a Parse.GeoPoint. For example, to create a point with latitude of 40.0 degrees and -30.0 degrees longitude:

var point = new Parse.GeoPoint({latitude: 40.0, longitude: -30.0});
This point is then stored in the object as a regular field.

placeObject.set("location", point);
Note: Currently only one key in a class may be a Parse.GeoPoint.

Geo Queries

Now that you have a bunch of objects with spatial coordinates, it would be nice to find out which objects are closest to a point. This can be done by adding another restriction to Parse.Query using near. Getting a list of ten places that are closest to a user may look something like:

// User's location
var userGeoPoint = userObject.get("location");
// Create a query for places
var query = new Parse.Query(PlaceObject);
// Interested in locations near user.
query.near("location", userGeoPoint);
// Limit what could be a lot of points.
query.limit(10);
// Final list of objects
query.find({
  success: function(placesObjects) {
  }
});
At this point placesObjects will be an array of objects ordered by distance (nearest to farthest) from userGeoPoint.

To limit the results using distance, check out withinMiles, withinKilometers, and withinRadians.

It's also possible to query for the set of objects that are contained within a particular area. To find the objects in a rectangular bounding box, add the withinGeoBox restriction to your Parse.Query.

var southwestOfSF = new Parse.GeoPoint(37.708813, -122.526398);
var northeastOfSF = new Parse.GeoPoint(37.822802, -122.373962);
 
var query = new Parse.Query(PizzaPlaceObject);
query.withinGeoBox("location", southwestOfSF, northeastOfSF);
query.find({
  success: function(pizzaPlacesInSF) {
    ...
  }
});
Caveats

At the moment there are a couple of things to watch out for:

Each Parse.Object class may only have one key with a Parse.GeoPoint object.
Points should not equal or exceed the extreme ends of the ranges. Latitude should not be -90.0 or 90.0. Longitude should not be -180.0 or 180.0. Attempting to set latitude or longitude out of bounds will cause an error.
Push Notifications

Basic Alerts

You can send push notifications using Parse.Push.send. It takes two arguments, a JSON object containing the push request and an options object that has a success and error function.

The JSON object that configures the push can have the following fields set:

channels - a set of channels to push to.
type - the type of device to push to ("ios" or "android" or empty to push to both).
push_time - A Date object for when to send the push.
expiration_time - A Date object for when to expire the push.
expiration_interval - The seconds from now to expire the push.
where - A Parse.Query over Parse.Installation that is used to match a set of installations to push to.
data - The data to send as part of the push
The iOS guide and Android guide have more information on how to subscribe a device to channels. For example, if you have subscribed all devices to the broadcast channel "", you could target an alert to all devices using the following command:

Parse.Push.send({
  channels: [ "" ],
  data: {
    alert: "Tune in for the World Series, tonight at 8pm EDT"
  }
}, {
  success: function() {
    // Push was successful
  },
  error: function(error) {
    // Handle error
  }
});
You could also target an alert to only iOS devices which are subscribed to the "redsox" or "yankees" channels.

Parse.Push.send({
  data: {
    alert: "Red Sox win 7-0!"
  },
  channels: ["redsox", "yankees"],
  type: "ios"
}, {
  success: function() {
    // Push was successful
  },
  error: function(error) {
    // Handle error
  }
});
Sending Custom Data

The data dictionary in your push will be available to your client code's push notification callback. (Note that iOS push payloads cannot exceed 256 bytes, which equates to approximately 200 bytes in the data dictionary). While the dictionary can have arbitrary keys and values, some keys are handled specially by one or both SDKs. If a key is recognized by only one SDK, you can still send the notification to both device types, just be aware that it will only have the special effect on one device type. The recognized keys are:

alert is a string which will be displayed to the user. In iOS it will be displayed as a popup dialog and in Android it will displayed in the system tray.
badge is an iOS-specific value that changes the badge of the application icon. This usually indicates the number of events that the user needs to catch up on. If it is set to a number, the targeted installations will have their "badge" field updated and their application icons will be badged with that value. If it is set to Increment, each targeted installation will have its badge field incremented and the resulting value will be used as the badge in the push payload. Omitting this field will leave badges unchanged.
sound is an iOS-specific string representing the name of a sound file in the application bundle to play. The default sound is played if you specify a sound that doesn't exist or "default".
content-available is an iOS-specific number which should be set to 1 to signal a Newsstand app to begin a background download.
action is an Android-specific string indicating that an Intent should be fired with the given action type. If you specify an "action" and do not specify an alert or title, then no system tray notification will be shown to Android users.
title is an Android-specific string that will be used to set a title on the Android system tray notification.
For example, this would send an alert that uses the "chime" sound and increments each device's badge in iOS, and has the title "Baseball News" in Android:

Parse.Push.send({
  channels: [ "" ],
  data: {
    alert: "Tune in for the World Series, tonight at 8pm EDT",
    badge: "Increment",
    sound: "chime",
    title: "Baseball News"
  }
}, {
  success: function() {
    // Push was successful
  },
  error: function(error) {
    // Handle error
  }
});
You could also send custom data to your app. In iOS, this data will be available in certain app lifecycle callbacks, as described in the iOS developer docs. In Android, this data will be available in any receivers registered for the given Intent ("com.example.GAME_ANNOUNCEMENT" in this example). For example:

Parse.Push.send({
  channels: [ "" ],
  data: {
    alert: "The next World Series has been announced",
    action: "com.example.GAME_ANNOUNCEMENT",
    location: "New York City",
    date: "July 16, 2013"
  }
}, {
  success: function() {
    // Push was successful
  },
  error: function(error) {
    // Handle error
  }
});
Note that custom data can only be sent to iOS devices if it is attached to a user-visible push, and that data will not be received by the app if the user dismisses the notification. In Android, on the other hand, your custom data will be received as long as the push service is running, and you can also push data without any user-visible display by omitting the title and alert keys.

Scheduling Pushes

You can schedule a push in advance by specifying a push_time for your notification. The subscribers to your notification will be calculated at the scheduled time, not at the time the push is submitted. For example, if a user schedules a game reminder for a game on October 12, 2012 at noon UTC, you can schedule the push notification by sending:

Parse.Push.send({
  channels: [ "user_123" ],
  data: {
    alert: "You previously created a reminder for the game today"
  },
  push_time: new Date(2012, 10, 12)
}, {
  success: function() {
    // Push was successful
  },
  error: function(error) {
    // Handle error
  }
});
The scheduled time must in the future, and can be up to two weeks from now.

Setting Expirations

Push notifications are often time-sensitive, and aren't worth delivering unless they arrive by a certain time. To handle this situation, you can set a notification to expire at a certain time or after a certain time interval. If a targeted device remains off or doesn't have network access until after the expiration, then it will never receive the notification.

The "expiration_time" parameter can be used to set the expiration time to October 12, 2012 at noon UTC:

Parse.Push.send({
  channels: [ "" ],
  data: {
    alert: "Sign up by October 12, 2012 to receive a free hat"
  },
  expiration_time: new Date(2012, 10, 12)
}, {
  success: function() {
    // Push was successful
  },
  error: function(error) {
    // Handle error
  }
});
The expiration_time can be any date.

Alternatively, you can use the expiration_interval parameter to set a number of seconds after which the notification will expire. This parameter is relative to the push_time if it was specified, otherwise it is relative to now. For example, we can schedule a future push notification that expires after one day with:

Parse.Push.send({
  channels: [ "" ],
  data: {
    alert: "Sign up and receive a free team hat, today only!"
    },
  push_time: new Date(2012, 10, 12)
  expiration_interval: 86400
}, {
  success: function() {
    // Push was successful
  },
  error: function(error) {
    // Handle error
  }
});
Advanced Targeting

For iOS apps, Parse offers advanced push targeting that gives you additional control over who receives your notification. Instead of passing an array of channels to target, you can pass a Parse.Query over Parse.Installation in the where key of the dictionary that matches installations that will receive the push notification. It takes the same format as basic object queries, so see the query constraints section for more details on allowable where clauses.

For example, if you store a preferred language and app version in your app's installation objects, you can target an upgrade reminder with:

var query = new Parse.Query(Parse.Installation);
query.equalTo('language', 'en');
query.lessThan('version', '1.2');
Parse.Push.send({
  where: query,
  data: {
    alert: "Version 1.2 is now available in the app store!"
  },
  expiration_interval: 86400
}, {
  success: function() {
    // Push was successful
  },
  error: function(error) {
    // Handle error
  }
});
Views

We've included Parse.View which is just a copy of Backbone.View. Feel free to use it for constructing views in your app. Take a look at the Backbone.View API for details on how to use this class. Note that once you use Parse.View, you will need to include jQuery or a jQuery compatible $ method.

Converting Backbone Apps

If you already have an existing Backbone application, it's easy to convert it to use our JavaScript SDK. After converting, you'll end up with a collection of static files that contain all your app's functionality.

Read our Todo App with JavaScript tutorial where you will learn how to create the canonical Backbone todo application using Parse as the backend to persist user accounts and data.
Our JavaScript SDK is Backbone compatible, which means that our Parse.Object and Parse.Collection can be dropped in for Backbone.Model and Backbone.Collection with minor tweaks. Here's how to convert your app:

Follow the instructions for installing the SDK for an existing JavaScript app.
Replace all instances of Backbone.Model with Parse.Object. When doing so, url and urlRoot should be replaced with an appropriate className that maps your objects to a Parse class:

var BackboneTodo = Backbone.Model.extend({
  urlRoot: "/todos"
});
 
var ParseTodo = Parse.Object.extend({
  className: "Todo"
});
Replace all instances of Backbone.Collection with Parse.Collection and specify the Parse.Object class as the model. You should also specify a query so that the collection knows how to fetch the objects:

var ParseTodoCollection = Parse.Collection({
  model: ParseTodo
});
 
var todos = new ParseTodoCollection();
 
// Construct a query to get the current user's todo items
var query = Parse.Query(ParseTodo);
query.equalTo("user", Parse.User.current());
todos.query = query;
todos.fetch();
Anywhere you were constructing models from a server you'll need to construct a Parse.Query to grab the objects that you're interested in, similar to what we had to do for the query attribute on the Parse.Collection.

Add or update your app to use user authentication and apply ACLs as necessary to objects.
And that's it. Your app should be functional and using Parse as the backend.

Error Handling

Most Parse JavaScript functions report their success or failure using an object with callbacks, similar to a Backbone "options" object. The two primary callbacks used are success and error. success is called whenever an operation completes without errors. Generally, its parameter will be either the Parse.Object in the case of save or get, or an array of Parse.Object for find.

error is called for any kind of error that occurs when interacting with the Parse Cloud over the network. These errors are either related to problems connecting to the cloud or problems performing the requested operation. Let's take a look at another example. In the code below, we try to fetch an object with a non-existent objectId. The Parse Cloud will return an error - so here's how to handle it properly in your callback:

var query = new Parse.Query(Note);
query.get("aBcDeFgH", {
  success: function(results) {
    // This function will *not* be called.
    alert("Everything went fine!");
  },
  error: function(error) {
    // This will be called.
    // error is an instance of Parse.Error with details about the error.
    if (error.code === Parse.Error.OBJECT_NOT_FOUND) {
      alert("Uh oh, we couldn't find the object!");
    }
  }
});
The query might also fail because the device couldn't connect to the Parse Cloud. Here's the same callback but with a bit of extra code to handle that scenario:

var query = new Parse.Query(Note);
query.get("thisObjectIdDoesntExist", {
  success: function(results) {
    // This function will *not* be called.
    alert("Everything went fine!");
  },
  error: function(model, error) {
    // This will be called.
    // error is an instance of Parse.Error with details about the error.
    if (error.code === Parse.Error.OBJECT_NOT_FOUND) {
      alert("Uh oh, we couldn't find the object!");
    } else if (error.code === Parse.Error.CONNECTION_FAILED) {
      alert("Uh oh, we couldn't even connect to the Parse Cloud!");
    }
  }
});
For methods like save and signUp that affect a particular Parse.Object, the first argument to the error function will be the object itself, and the second will be the Parse.Error object. This is for compatibility with Backbone-type frameworks. For a list of all possible Parse.Error codes, see the Error Codes section of the JavaScript API.

Android Guide

If you haven't installed the SDK yet, please head over to the QuickStart guide to get our SDK up and running in Eclipse.

Introduction

The Parse platform provides a complete backend solution for your mobile application. Our goal is to totally eliminate the need for writing server code or maintaining servers.

If you're familiar with web frameworks like Ruby on Rails, we've taken many of the same principles and applied them to our platform. In particular, our SDK is ready to use out of the box with minimal configuration on your part.

Apps

On Parse, you create an App for each of your mobile applications. Each App has its own application id and client key that you apply to your SDK install. Your account on Parse can accommodate multiple Apps. This is useful even if you have one application, since you can deploy different versions for test and production.

Objects

The ParseObject

Storing data on Parse is built around the ParseObject. Each ParseObject contains key-value pairs of JSON-compatible data. This data is schemaless, which means that you don't need to specify ahead of time what keys exist on each ParseObject. You simply set whatever key-value pairs you want, and our backend will store it.

For example, let's say you're tracking high scores for a game. A single ParseObject could contain:

score: 1337, playerName: "Sean Plott", cheatMode: false
Keys must be alphanumeric strings. Values can be strings, numbers, booleans, or even arrays and objects - anything that can be JSON-encoded.

Each ParseObject has a class name that you can use to distinguish different sorts of data. For example, we could call the high score object a GameScore. We recommend that you NameYourClassesLikeThis and nameYourKeysLikeThis, just to keep your code looking pretty.

Saving Objects

Let's say you want to save the GameScore described above to the Parse Cloud. The interface is similar to a Map, plus the saveInBackground method:

ParseObject gameScore = new ParseObject("GameScore");
gameScore.put("score", 1337);
gameScore.put("playerName", "Sean Plott");
gameScore.put("cheatMode", false);
gameScore.saveInBackground();
After this code runs, you will probably be wondering if anything really happened. To make sure the data was saved, you can look at the Data Browser in your app on Parse. You should see something like this:

objectId: "xWMyZ4YEGZ", score: 1337, playerName: "Sean Plott", cheatMode: false,
createdAt:"2011-06-10T18:33:42Z", updatedAt:"2011-06-10T18:33:42Z"
There are two things to note here. You didn't have to configure or set up a new Class called GameScore before running this code. Your Parse app lazily creates this Class for you when it first encounters it.

There are also a few fields you don't need to specify that are provided as a convenience. objectId is a unique identifier for each saved object. createdAt and updatedAt represent the time that each object was created and last modified in the cloud. Each of these fields is filled in by Parse, so they don't exist on a ParseObject until a save operation has completed.

Retrieving Objects

Saving data to the cloud is fun, but it's even more fun to get that data out again. If you have the objectId, you can retrieve the whole ParseObject using a ParseQuery:

ParseQuery query = new ParseQuery("GameScore");
query.getInBackground("xWMyZ4YEGZ", new GetCallback() {
  public void done(ParseObject object, ParseException e) {
    if (e == null) {
      // object will be your game score
    } else {
      // something went wrong
    }
  }
});
To get the values out of the ParseObject, there's a getX method for each data type:

int score = gameScore.getInt("score");
String playerName = gameScore.getString("playerName");
boolean cheatMode = gameScore.getBoolean("cheatMode");
If you don't know what type of data you're getting out, you can call get(key), but then you probably have to cast it right away anyways. In most situations you should use the typed accessors like getString.

The three special values have their own accessors:

String objectId = gameScore.getObjectId();
Date updatedAt = gameScore.getUpdatedAt();
Date createdAt = gameScore.getCreatedAt();
If you need to refresh an object you already have with the latest data that is in the cloud, you can call the refreshInBackground method like so:

myObject.refreshInBackground(new RefreshCallback() {
  public void done(ParseObject object, ParseException e) {
    if (e == null) {
      // Success!
    } else {
      // Failure!
    }
  }
});
The code in the GetCallback will be run on the main thread.

Saving Objects Offline

Most save functions execute immediately, and inform your app when the save is complete. If you don't need to know when the save has finished, you can use saveEventually instead. The advantage is that if the user currently doesn't have a network connection, saveEventually will store the update on the device until a network connection is re-established. If your app is closed before the connection is back, Parse will try again the next time the app is opened. All calls to saveEventually (and deleteEventually) are executed in the order they are called, so it is safe to call saveEventually on an object multiple times.

ParseObject gameScore = new ParseObject("GameScore");
gameScore.put("score", 1337);
gameScore.put("playerName", "Sean Plott");
gameScore.put("cheatMode", false);
gameScore.saveEventually();
Updating Objects

Updating an object is simple. Just set some new data on it and call one of the save methods. For example:

// Create the object.
final ParseObject gameScore = new ParseObject("GameScore");
gameScore.put("score", 1337);
gameScore.put("playerName", "Sean Plott");
gameScore.put("cheatMode", false);
gameScore.put("skills", Arrays.asList("pwnage", "flying"));
gameScore.saveInBackground(new SaveCallback() {
  public void done(ParseException e) {
    // Now let's update it with some new data. In this case, only cheatMode and score
    // will get sent to the Parse Cloud. playerName hasn't changed.
    gameScore.put("score", 1338);
    gameScore.put("cheatMode", true);
    gameScore.saveInBackground();
  }
});
Parse automatically figures out which data has changed so only "dirty" fields will be transmitted during a save. You don't need to worry about squashing data in the cloud that you didn't intend to update.

Counters

The above example contains a common use case. The "score" field is a counter that we'll need to continually update with the player's latest score. Using the above method works but it's cumbersome and can lead to problems if you have multiple clients trying to update the same counter.

To help with storing counter-type data, Parse provides methods that atomically increment (or decrement) any number field. So, the same update can be rewritten as:

gameScore.increment("score");
gameScore.saveInBackground();
You can also increment by any amount using increment(key, amount).

Arrays

To help with storing array data, there are three operations that can be used to atomically change an array field:

add and addAll append the given objects to the end of an array field.
addUnique and addAllUnique add only the given objects which aren't already contained in an array field to that field. The position of the insert is not guaranteed.
removeAll removes all instances of the given objects from an array field.
For example, we can add items to the set-like "skills" field like so:

gameScore.addAllUnique("skills", Arrays.asList("flying", "kungfu"));
gameScore.saveInBackground();
Deleting Objects

To delete an object from the Parse Cloud:

myObject.deleteInBackground();
If you want to run a callback when the delete is confirmed, you can provide a DeleteCallback to the deleteInBackground method. If you want to block the calling thread, you can use the delete method.

You can delete a single field from an object with the remove method:

// After this, the playerName field will be empty
myObject.remove("playerName");
 
// Saves the field deletion to the Parse Cloud
myObject.saveInBackground();
Relational Data

Objects can have relationships with other objects. To model this behavior, any ParseObject can be used as a value in other ParseObjects. Internally, the Parse framework will store the referred-to object in just one place, to maintain consistency.

For example, each Comment in a blogging app might correspond to one Post. To create a new Post with a single Comment, you could write:

// Create the post
ParseObject myPost = new ParseObject("Post");
myPost.put("title", "I'm Hungry");
myPost.put("content", "Where should we go for lunch?");
 
// Create the comment
ParseObject myComment = new ParseObject("Comment");
myComment.put("content", "Let's do Sushirrito.");
 
// Add a relation between the Post and Comment
myComment.put("parent", myPost);
 
// This will save both myPost and myComment
myComment.saveInBackground();
By default, when fetching an object, related ParseObjects are not fetched. These objects' values cannot be retrieved until they have been fetched like so:

fetchedComment.getParseObject("post").fetchIfNeededInBackground(new GetCallback() {
  public void done(ParseObject object, ParseException e) {
    String title = post.getString("title");
  }
});
You can also model a many-to-many relation using the ParseRelation object. This works similar to List, except that you don't need to download all the ParseObjects in a relation at once. This allows ParseRelation to scale to many more objects than the List approach. For example, a User may have many Posts that they might like. In this case, you can store the set of Posts that a User likes using getRelation. In order to add a post to the list, the code would look something like:

ParseUser user = ParseUser.getCurrentUser();
ParseRelation relation = user.getRelation("likes");
relation.add(post);
user.saveInBackground();
You can remove a post from the ParseRelation with something like:

relation.remove(post);
By default, the list of objects in this relation are not downloaded. You can get the list of Posts by calling findInBackground on the ParseQuery returned by getQuery. The code would look like:

relation.getQuery().findInBackground(new FindCallback() {
    void done(List<ParseObject> results, ParseException e) {
      if (e != null) {
        // There was an error
      } else {
        // results have all the Posts the current user liked.
      }
    }
});
If you want only a subset of the Posts you can add extra constraints to the ParseQuery returned by getQuery. The code would look something like:

ParseQuery query = relation.getQuery();
// Add other query constraints.
For more details on ParseQuery, please look at the query portion of this guide. A ParseRelation behaves similar to a List for querying purposes, so any queries you can do on lists of objects you can do on ParseRelation.

Data Types

So far we've used values with type String, int, bool, and ParseObject. Parse also supports java.util.Date, byte[], and JSONObject.NULL.

You can nest JSONObject and JSONArray objects to store more structured data within a single ParseObject.

Some examples:

int myNumber = 42;
String myString = "the number is " + myNumber;
Date myDate = new Date();
 
JSONArray myArray = new JSONArray();
myArray.put(myString);
myArray.put(myNumber);
 
JSONObject myObject = new JSONObject();
myObject.put("number", myNumber);
myObject.put("string", myString);
 
byte[] myData = { 4, 8, 16, 32 };
 
ParseObject bigObject = new ParseObject("BigObject");
bigObject.put("myNumber", myNumber);
bigObject.put("myString", myString);
bigObject.put("myDate", myDate);
bigObject.put("myData", myData);
bigObject.put("myArray", myArray);
bigObject.put("myObject", myObject);
bigObject.put("myNull", JSONObject.NULL);
bigObject.saveInBackground();
We do not recommend storing large pieces of binary data like images or documents using byte[] fields on ParseObject. ParseObjectss should not exceed 128 kilobytes in size. To store more, we recommend you use ParseFile. See the guide section for more details.

For more information about how Parse handles data, check out our documentation on Data & Security.

Other Operations

Parse provides a number of convenient operations on ParseObject to help you manage your data.

Counters

Many apps keep counter data -- whether it's to track game scores, gold coins, or even sheep. Parse provides an easy way to atomically update your counter data. For example:

ParseObject player = new ParseObject("Player");
player.put("goldCoins", 1);
player.saveInBackground();
 
// Later ..
player.increment("goldCoins");
player.saveInBackground();
You can also increment by any amount using increment(key, .

Queries

Basic Queries

In many cases, getInBackground isn't powerful enough to specify which objects you want to retrieve. The ParseQuery offers different ways to retrieve a list of objects rather than just a single object.

The general pattern is to create a ParseQuery, put conditions on it, and then retrieve a List of matching ParseObjects using the findInBackground method with a FindCallback. For example, to retrieve scores with a particular playerName, use the whereEqualTo method to constrain the value for a key:

ParseQuery query = new ParseQuery("GameScore");
query.whereEqualTo("playerName", "Dan Stemkoski");
query.findInBackground(new FindCallback() {
    public void done(List<ParseObject> scoreList, ParseException e) {
        if (e == null) {
            Log.d("score", "Retrieved " + scoreList.size() + " scores");
        } else {
            Log.d("score", "Error: " + e.getMessage());
        }
    }
});
findInBackground works similarly to getInBackground in that it assures the network request is done on a background thread, and runs its callback in the main thread.

Query Constraints

There are several ways to put constraints on the objects found by a ParseQuery. You can filter out objects with a particular key-value pair with whereNotEqualTo:

query.whereNotEqualTo("playerName", "Michael Yabuti");
You can give multiple constraints, and objects will only be in the results if they match all of the constraints. In other words, it's like an AND of constraints.

query.whereNotEqualTo("playerName", "Michael Yabuti");
query.whereGreaterThan("playerAge", 18);
You can limit the number of results with setLimit. By default, results are limited to 100, but anything from 1 to 1000 is a valid limit:

query.setLimit(10); // limit to at most 10 results
If you want exactly one result, a more convenient alternative may be to use getFirst or getFirstBackground instead of using find.

ParseQuery query = new ParseQuery("GameScore");
query.whereEqualTo("playerEmail", "dstemkoski@example.com");
query.getFirstInBackground(new GetCallback() {
  public void done(ParseObject* object, ParseException e) {
    if (object == null) {
      Log.d("score", "The getFirst request failed.");
    } else {
      Log.d("score", "Retrieved the object.");
    }
  }
});
You can skip the first results with setSkip. This can be useful for pagination:

query.setSkip(10); // skip the first 10 results
For sortable types like numbers and strings, you can control the order in which results are returned:

// Sorts the results in ascending order by the score field
query.orderByAscending("score");
 
// Sorts the results in descending order by the score field
query.orderByDescending("score");
You can add more sort keys to the query as follows:

// Sorts the results in ascending order by the score field if the previous sort keys are equal.
query.addAscendingOrder("score");
 
// Sorts the results in descending order by the score field if the previous sort keys are equal.
query.addDescendingOrder("score");
For sortable types, you can also use comparisons in queries:

// Restricts to wins < 50
query.whereLessThan("wins", 50);
 
// Restricts to wins <= 50
query.whereLessThanOrEqualTo("wins", 50);
 
// Restricts to wins > 50
query.whereGreaterThan("wins", 50);
 
// Restricts to wins >= 50
query.whereGreaterThanOrEqualTo("wins", 50);
If you want to retrieve objects matching several different values, you can use whereContainedIn, providing a collection of acceptable values. This is often useful to replace multiple queries with a single query. For example, if you want to retrieve scores made by any player in a particular list:

String[] names = {"Jonathan Walsh", "Dario Wunsch", "Shawn Simon"};
query.whereContainedIn("playerName", Arrays.asList(names));
If you want to retrieve objects that do not match any of several values you can use whereKey:notContainedIn:, providing an array of acceptable values. For example, if you want to retrieve scores from players besides those in a list:

String[] names = {"Jonathan Walsh", "Dario Wunsch", "Shawn Simon"};
query.whereNotContainedIn("playerName", Arrays.asList(names));
If you want to retrieve objects that have a particular key set, you can use whereExists. Conversely, if you want to retrieve objects without a particular key set, you can use whereDoesNotExist.

// Finds objects that have the score set
query.whereExists("score");
 
// Finds objects that don't have the score set
query.whereDoesNotExist("score");
You can use the whereMatchesKeyInQuery method to get objects where a key matches the value of a key in a set of objects resulting from another query. For example, if you have a class containing sports teams and you store a user's hometown in the user class, you can issue one query to find the list of users whose hometown teams have winning records. The query would look like:

ParseQuery teamQuery = new ParseQuery("Team");
teamQuery.whereGreaterThan("winPct", 0.5);
ParseQuery userQuery = ParseUser.getQuery();
userQuery.whereMatchesKeyInQuery("hometown", "city", teamQuery);
userQuery.findInBackground(new FindCallback() {
  void done(List<ParseObject> results, ParseException e) {
    // results has the list of users with a hometown team with a winning record
  }
});
Queries on Array Values

If a key contains an array value, you can search for objects where the key's array value contains 2 by:

// Find objects where the array in arrayKey contains the number 2.
    query.whereEqualTo("arrayKey", 2);
Queries on String Values

There are several ways you can search over values containing strings. For any regular expression, you can use whereMatches to retrieve only the values that match it:

// Finds barbecue sauces that start with a capital letter and a digit.
ParseQuery query = new ParseQuery("BarbecueSauce");
query.whereMatches("name", "^[A-Z]\\d");
 
query.findInBackground(new FindCallback() {
  public void done(List<ParseObject> sauceList, ParseException e) {
    // The sauces could have, for example, name = "A1 Steak Sauce"
  }
});
Parse uses the Perl-compatible regular expression format. Since the regular expression string is escaped by Java before being interpreted by the regular expression engine, be sure that you replace backslashes for the regular expression with double backslashes.

whereMatches has an overload which supports many standard PCRE modifier characters:
i - Case insensitive search
m - Search across multiple lines of input
// Some people type "BBQ", others type "bbq". Consider them the same thing with the i modifier.
// The m modifier helps us find sauces that call themselves "bbq sauce" after the first line of text.
ParseQuery query = new ParseQuery("Sauce");
query.whereMatches("description", "bbq", "im");
 
query.findInBackground(new FindCallback() {
  public void done(List<ParseObject> sauceList, ParseException e) {
    // Sauces that call themselves a "bbq" sauce.
  }
});
There are also several helper functions for standard string operations: substrings, prefixes, and suffixes. Use whereContains to restrict to string values containing a substring:

// Finds barbecue sauces that contain the string "Extra Spicy!".
ParseQuery query = new ParseQuery("BarbecueSauce");
query.whereContains("name", "Extra Spicy!");
Use whereStartsWith to restrict to string values that start with a particular string. Similar to a MySQL LIKE operator, this is indexed so it is efficient for large datasets:

// Finds barbecue sauces that start with "Big Daddy's".
ParseQuery query = new ParseQuery("BarbecueSauce");
query.whereStartsWith("name", "Big Daddy's");
Use whereEndsWith to restrict to string values that end with a particular string:

// Finds barbecue sauces that end with "Original Recipe".
ParseQuery query = new ParseQuery("BarbecueSauce");
query.whereEndsWith("name", "Original Recipe");
Relational Queries

There are several ways to issue queries for relational data. If you want to retrieve objects where a field matches a particular ParseObject, you can use whereEqualTo just like for other data types. For example, if each Comment has a Post object in its post field, you can fetch comments for a particular Post:

// Assume ParseObject myPost was previously created.
ParseQuery query = new ParseQuery("Comment");
query.whereEqualTo("post", myPost);
 
query.findInBackground(new FindCallback() {
  public void done(List<ParseObject> commentList, ParseException e) {
    // commentList now has the comments for myPost
  }
});
If you want to retrieve objects where a field contains a ParseObject that matches a different query, you can use whereMatchesQuery. Note that the default limit of 100 and maximum limit of 1000 apply to the inner query as well, so with large data sets you may need to construct queries carefully to get the desired behavior. In order to find comments for posts containing images, you can do:

ParseQuery innerQuery = new ParseQuery("Post");
innerQuery.whereExists("image");
ParseQuery query = new ParseQuery("Comment");
query.whereMatchesQuery(innerQuery);
query.findInBackground(new FindCallback() {
  public void done(List<ParseObject> commentList, ParseException e) {
    // comments now contains the comments for posts with images.
  }
});
If you want to retrieve objects where a field contains a ParseObject that does not match a different query, you can use whereDoesNotMatchQuery. In order to find comments for posts without images, you can do:

ParseQuery innerQuery = new ParseQuery("Post");
innerQuery.whereExists("image");
ParseQuery query = new ParseQuery("Comment");
query.whereDoesNotMatchQuery(innerQuery);
query.findInBackground(new FindCallback() {
  public void done(List<ParseObject> commentList, ParseException e) {
    // comments now contains the comments for posts without images.
  }
});
In some situations, you want to return multiple types of related objects in one query. You can do this with the include method. For example, let's say you are retrieving the last ten comments, and you want to retrieve their related posts at the same time:

ParseQuery query = new ParseQuery("Comment");
 
// Retrieve the most recent ones
query.orderByDescending("createdAt");
 
// Only retrieve the last ten
query.setLimit(10);
 
// Include the post data with each comment
query.include("post");
 
query.findInBackground(new FindCallback() {
  public void done(List<ParseObject> commentList, ParseException e) {
    // commentList now contains the last ten comments, and the "post"
    // field has been populated. For example:
    for (ParseObject comment : commentList) {
      // This does not require a network access.
      ParseObject post = comment.getParseObject("post");
      Log.d("post", "retrieved a related post");
    }
  }
});
You can also do multi level includes using dot notation. If you wanted to include the post for a comment and the post's author as well you can do:

query.include("post.author");
You can issue a query with multiple fields included by calling include multiple times. This functionality also works with ParseQuery helpers like getFirst() and getInBackground()

Caching Queries

It's often useful to cache the result of a query on disk. This lets you show data when the user's device is offline, or when the app has just started and network requests have not yet had time to complete. Parse takes care of automatically flushing the cache when it takes up too much space.

The default query behavior doesn't use the cache, but you can enable caching with setCachePolicy. For example, to try the network and then fall back to cached data if the network is not available:

query.setCachePolicy(ParseQuery.CachePolicy.NETWORK_ELSE_CACHE);
query.findInBackground(new FindCallback() {
public void done(List<ParseObject> scoreList, ParseException e) {
  if (e == null) {
    // Results were successfully found, looking first on the
    // network and then on disk.
  } else {
    // The network was inaccessible and we have no cached data
    // for this query.
  }
});
Parse provides several different cache policies:

IGNORE_CACHE 
The query does not load from the cache or save results to the cache. IGNORE_CACHE is the default cache policy.
CACHE_ONLY 
The query only loads from the cache, ignoring the network. If there are no cached results, that causes a ParseException.
NETWORK_ONLY 
The query does not load from the cache, but it will save results to the cache.
CACHE_ELSE_NETWORK 
The query first tries to load from the cache, but if that fails, it loads results from the network. If neither cache nor network succeed, there is a ParseException.
NETWORK_ELSE_CACHE 
The query first tries to load from the network, but if that fails, it loads results from the cache. If neither network nor cache succeed, there is a ParseException.
CACHE_THEN_NETWORK 
The query first loads from the cache, then loads from the network. In this case, the FindCallback will actually be called twice - first with the cached results, then with the network results. This cache policy can only be used asynchronously with findInBackground.
If you need to control the cache's behavior, you can use methods provided in ParseQuery to interact with the cache. You can do the following operations on the cache:

Check to see if there is a cached result for the query with:
boolean isInCache = query.hasCachedResult();
Remove any cached results for a query with:
query.clearCachedResult();
Remove cached results for all queries with:
ParseQuery.clearAllCachedResults();
Control the maximum age of a cached result with:
query.setMaxCacheAge(TimeUnit.DAYS.toMillis(1));
Query caching also works with ParseQuery helpers including getFirst() and getInBackground().
Counting Objects

If you just need to count how many objects match a query, but you do not need to retrieve all the objects that match, you can use count instead of find. For example, to count how many games have been played by a particular player:

ParseQuery query = new ParseQuery("GameScore");
query.whereEqualTo("playerName", "Sean Plott");
query.countInBackground(new CountCallback() {
  public void done(int count, ParseException e) {
    if (e == null) {
      // The count request succeeded. Log the count
      Log.d("score", "Sean has played " + count + " games");
    } else {
      // The request failed
    }
  }
});
If you want to block the calling thread, you can also use the synchronous query.count() method.
Compound Queries

If you want to find objects that match one of several queries, you can use ParseQuery.or method to construct a query that is an or of the queries passed in. For instance if you want to find players who either have a lot of wins or a few wins, you can do:

ParseQuery lotsOfWins = new ParseQuery("Player");
lotsOfWins.whereGreaterThan(150);
 
ParseQuery fewWins = new ParseQuery("Player");
fewWins.whereLessThan(5);
 
List<ParseQuery> queries = new ArrayList<ParseQuery>();
queries.add(lotsOfWins);
queries.add(fewWins);
 
ParseQuery mainQuery = ParseQuery.or(queries);
mainQuery.findInBackground(new FindCallback() {
  public void done(List<ParseObject> results, ParseException e) {
    // results has the list of players that win a lot or haven't won much.
  }
});
You can also add more constraints to the newly constructed ParseQuery which act as an 'and' operator.

Files

The ParseFile

ParseFile lets you store application files in the cloud that would otherwise be too large or cumbersome to fit into a regular ParseObject. The most common use case is storing images but you can also use it for documents, videos, music, and any other binary data (up to 10 megabytes).

Getting started with ParseFile is easy. First, you'll need to have the data in byte[] form and then create a ParseFile with it. In this example, we'll just use a string:

byte[] data = "Working at Parse is great!".getBytes();
ParseFile file = new ParseFile("resume.txt", data);
Notice in this example that we give the file a name of resume.txt. There's two things to note here:

You don't need to worry about filename collisions. Each upload gets a unique identifier so there's no problem with uploading multiple files named resume.txt.
It's important that you give a name to the file that has a file extension. This lets Parse figure out the file type and handle it accordingly. So, if you're storing PNG images, make sure your filename ends with .png.
Next you'll want to save the file up to the cloud. As with ParseObject, there are many variants of the save method you can use depending on what sort of callback and error handling suits you.

file.saveInBackground();
Finally, after the save completes, you can associate a ParseFile onto a ParseObject just like any other piece of data:

ParseObject jobApplication = new ParseObject("JobApplication");
jobApplication.put("applicantName", "Joe Smith");
jobApplication.put("applicantResumeFile", file);
jobApplication.saveInBackground();
Retrieving it back involves calling one of the getData variants on the ParseObject. Here we retrieve the resume file off another JobApplication object:

ParseFile applicantResume = (ParseFile)anotherApplication.get("applicantResumeFile");
applicantResume.getDataInBackground(new GetDataCallback() {
  public void done(byte[] data, ParseException e) {
    if (e == null) {
      // data has the bytes for the resume
    } else {
      // something went wrong
    }
  }
});
Just like on ParseObject, you will most likely want to use the background version of getData.

Progress

It's easy to get the progress of both uploads and downloads using ParseFile by passing a ProgressCallback to saveInBackground and getDataInBackground. For example:

byte[] data = "Working at Parse is great!".getBytes();
ParseFile file = new ParseFile("resume.txt", data);
 
file.saveInBackground(new SaveCallback() {
  public void done(ParseException e) {
    // Handle success or failure here ...
  }
}, new ProgressCallback() {
  public void done(Integer percentDone) {
    // Update your progress spinner here. percentDone will be between 0 and 100.
  }
});
Push Notifications

Adding Push To Your App

Push notifications let your application notify a user of new messages or events even when the user is not actively using your application. On Android devices, when a device receives a push notification, your application's icon and a message appear in the status bar. When the user taps the notification, they are sent to your application. Notifications can be broadcast to all users, such as for a marketing campaign, or sent to just a subset of users, to give personalized information.

The Parse library provides push notifications by running a background service that keeps an internet connection to the Parse Cloud. This method of push notification is compatible back to Android 1.5 and does not require an active Google account on the phone.

To use push notifications, your application must register this background service. Add the following XML to your AndroidManifest.xml file immediately before the closing </application> tag:

<service android:name="com.parse.PushService" />
<receiver android:name="com.parse.ParseBroadcastReceiver">
  <intent-filter>
    <action android:name="android.intent.action.BOOT_COMPLETED" />
    <action android:name="android.intent.action.USER_PRESENT" />
  </intent-filter>
</receiver>
Next, your application must have the permissions needed to show a notification. Make sure that these permissions are present in your AndroidManifest.xml file, typically immediately before the closing </manifest> tag:

<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
<uses-permission android:name="android.permission.VIBRATE" />
Finally, your application needs to inform the Parse Cloud that it is ready for notifications. The simplest way to get started is to subscribe your application to the global broadcast channel, represented by the empty string. Add this line of code anywhere within a valid activity, such as the onCreate method of your main activity:

PushService.subscribe(this, "", YourActivity.class);
At this point, you're ready to send push notifications. From the "Push Notifications" tab, you can use the provided text box to all of your app's users. Unlike iOS, Android push notifications do work from the emulator, so you can use the emulator to test out push.

Channels

Channels are a flexible way to send push notifications to segments of your users. A channel is identified by a string that starts with a letter and consists of alphanumeric characters, underscores, and dashes. Channels don't need to be explicitly created before they are used. Each instance of your application can subscribe to any number of channels at a time. Subscribing to a channel is a single method call:

PushService.subscribe(context, "yourChannelName", YourActivity.class);
The provided Activity class specifies which Activity will be run when a user responds to notifications on this channel. This lets you handle push notifications on different channels in different ways.

Unsubscribing from a channel is also a single method call:

PushService.unsubscribe(context, "yourChannelName");
Neither the subscribe method nor the unsubscribe method blocks the thread it is called from. The subscription information is cached on the device's disk if the network is inaccessible and transmitted to the Parse Cloud as soon as the network is usable. This means you don't have to worry about threading or callbacks while managing subscriptions.

You can use channels in a variety of ways. For example:

A sports scores app might have a channel for each team (e.g. 'giants_scores', 'yankees_scores') so that it can send scores to a team's fans whenever a game ends.
A group chat app might have a channel for each group (e.g. 'group_1', 'group_2') so that it can send messages whenever someone chats in the group.
A travel app might have have a channel for each flight (e.g. 'united_259', 'delta_30') so that it can send flight delays to users on each flight.
A chess game app might have a channel for each match (e.g. 'match_1', 'match_2') so that it can send messages when a move is made.
An app with user accounts might have a channel for each user (e.g. 'user_1', 'user_2') so that it can send messages to a user across all their devices and have users follow others in the app.
By convention, apps that want to broadcast messages to all of their users can have each user subscribe to the empty string channel, also referred to as the global broadcast channel.

To provide an interface for controlling with channels a user is subscribed to, it is often useful to access the set of active channel subscriptions. This is provided via the static method:

Set<String> setOfAllSubscriptions = PushService.getSubscriptions();
Sending Notifications

There are several ways to send push notifications using Parse.

Web Interface

The simplest way to send push notifications is through your Parse app's console. Head over to the "Push Notifications" tab and use the provided fields to send a message to one or more of your app's channels. The REST docs describe the behavior of each field in the web interface.

From Your App

You can send push notifications directly from your app using the client SDK's ParsePush object if you set "Client push enabled?" to Yes under the "Push Notifications" tab. More granular security settings are slated for an upcoming release.

To send a simple alert to all Android devices on the global broadcast channel, which will show up as a system tray notification, do the following:

ParsePush push = new ParsePush();
push.setMessage("Red Sox win 7-0!");
push.sendInBackground();
By default, push notifications sent from Android clients target only Android devices, because iOS push notifications require Apple certificates to work. If you have configured iOS push and want to send an alert to both iOS and Android devices, you can do the following:

ParsePush push = new ParsePush();
push.setPushToIOS(true);
push.setMessage("Red Sox win 7-0!");
push.sendInBackground();
To send a more complicated push which targets only Android devices on the "REDSOX" and "YANKEES" channels, fires an Android Intent with custom data, and expires one day from now, do the following:

LinkedList<String> channels = new LinkedList<String>();
channels.add("REDSOX");
channels.add("YANKEES");
 
ParsePush push = new ParsePush();
push.setChannels(channels);
push.setExpirationTimeInterval(86400);
push.setData(new JSONObject("{\"action\": \"com.example.UPDATE_SCORE\",
                              \"inning\": \"4th\",
                              \"score_REDSOX\": \"5\",
                              \"score_YANKEES\": \"0\""}));
push.sendInBackground();
You can also send pushes to specific devices which match a query. For example, to remind east-coast users to catch the upcoming Yankees vs Redsox game:

ParseQuery query = ParseInstallation.query();
query.whereEqualTo("timezone", "America/new_york");
ParsePush.sendMessageInBackground("Don't forget to catch tonight's game!", query);
Check out the Android Javadoc for more details and other variants of the push sending methods.

REST API

You can send push notifications from any machine using our REST API.
Receiving Notifications

You can easily display a system tray message to users who receive a push notification on a subscribed channel. This is the default action of sending a message via the web UI, and can also be done by calling setMessage in a client SDK push or setting the "alert" or "title" entries in the "data" dictionary described in the REST API.

If you send a push via the client SDK or the REST API, you can also specify an Intent to be fired when the push notification is received (not the time the user taps the push notification). This will allow your app to perform custom handling for the notification, and can be used whether or not you have chosen to display a system tray message. To implement custom notification handling, set the "action" entry in your push notification data dictionary to the Intent action which you want to fire, as described in the REST API docs. Android guidelines suggest that you prefix the action with your package name to avoid namespace collisions with other running apps.

If your code lives in the com.example package and you want to register a receiver for the com.example.UPDATE_SCORE action, you can add the following XML to your AndroidManifest.xml file, immediately after the end of the ParseBroadcastReceiver block that you created earlier:

<receiver android:name="com.example.MyCustomReceiver">
  <intent-filter>
    <action android:name="com.example.UPDATE_SCORE" />
  </intent-filter>
</receiver>
Your custom receiver will be called whenever a push notification is received with an action parameter of com.example.UPDATE_SCORE. The Intent object which is passed to the receiver contains an extras Bundle with two useful mappings. The "com.parse.Channel" key points to a string representing the channel that the message was sent on (this key is being deprecated as we introduce multi-channel push targeting, but it will continue to work for single-channel pushes). The "com.parse.Data" key points to a string representing the JSON-encoded value of the "data" dictionary that was set in the push notification. As an example, the following code will parse a JSON push notification and log it to the Android emulator console:

public class MyCustomReceiver extends BroadcastReceiver {
  private static final String TAG = "MyCustomReceiver";
 
  @Override
  public void onReceive(Context context, Intent intent) {
    try {
      String action = intent.getAction();
      String channel = intent.getExtras().getString("com.parse.Channel");
      JSONObject json = new JSONObject(intent.getExtras().getString("com.parse.Data"));
 
      Log.d(TAG, "received action " + action + " on channel " + channel + " with extras:");
      Iterator itr = json.keys();
      while (itr.hasNext()) {
        String key = (String) itr.next();
        Log.d(TAG, "..." + key + " => " + json.getString(key));
      }
    } catch (JSONException e) {
      Log.d(TAG, "JSONException: " + e.getMessage());
    }
  }
}
Troubleshooting

If your push notifications aren't working, try the following:
Make sure you have included the service and permissions in your AndroidManifest.xml file, and included them in the right place - mistakes in the format will often silently fail.
Make sure you call Parse.initialize from within your Application.onCreate, not an Activity.onCreate, otherwise the service will not know how to talk to Parse if it launches before your main activity.
Check the output of adb logcat | grep -i parse to see if there are helpful error messages.
Contact us at feedback@parse.com!
Users

At the core of many apps, there is a notion of user accounts that lets users access their information in a secure manner. We provide a specialized user class called ParseUser that automatically handles much of the functionality required for user account management.

With this class, you'll be able to add user account functionality in your app.

ParseUser is a subclass of the ParseObject, and has all the same features, such as flexible schema, automatic persistence, and a key value interface. All the methods that are on ParseObject also exist in ParseUser. The difference is that ParseUser has some special additions specific to user accounts.

Properties

ParseUser has several properties that set it apart from ParseObject:

username: The username for the user (required).
password: The password for the user (required on signup).
email: The email address for the user (optional).
We'll go through each of these in detail as we run through the various use cases for users. Keep in mind that if you set username and email using the setters, you do not need to set it using the put method.

Signing Up

The first thing your app will do is probably ask the user to sign up. The following code illustrates a typical sign up:

ParseUser user = new ParseUser();
user.setUsername("my name");
user.setPassword("my pass");
user.setEmail("email@example.com");
 
// other fields can be set just like with ParseObject
user.put("phone", "650-253-0000");
 
user.signUpInBackground(new SignUpCallback() {
  public void done(ParseException e) {
    if (e == null) {
      // Hooray! Let them use the app now.
    } else {
      // Sign up didn't succeed. Look at the ParseException
      // to figure out what went wrong
    }
  }
});
This call will asynchronously create a new user in your Parse App. Before it does this, it checks to make sure that both the username and email are unique. Also, it securely hashes the password in the cloud. We never store passwords in plaintext, nor will we ever transmit passwords back to the client in plaintext.

Note that we used the signUpInBackground method, not the saveInBackground method. New ParseUsers should always be created using the signUpInBackground (or signUp) method. Subsequent updates to a user can be done by calling save.

The signUpInBackground method comes in various flavors, with the ability to pass back errors, and also synchronous versions. As usual, we highly recommend using the asynchronous versions when possible, so as not to block the UI in your app. You can read more about these specific methods in our API docs.

If a signup isn't successful, you should read the error object that is returned. The most likely case is that the username or email has already been taken by another user. You should clearly communicate this to your users, and ask them try a different username.

You are free to use an email addresses as the username. Simply ask your users to enter their email, but fill it in the username property — ParseUser will work as normal. We'll go over how this is handled in the reset password section.

Logging In

Of course, after you allow users to sign up, you need be able to let them log in to their account in the future. To do this, you can use the class method logInInBackground.

ParseUser.logInInBackground("Jerry", "showmethemoney", new LogInCallback() {
  public void done(ParseUser user, ParseException e) {
    if (user != null) {
      // Hooray! The user is logged in.
    } else {
      // Signup failed. Look at the ParseException to see what happened.
    }
  }
});
Verifying Emails

Enabling email verification in an application's settings allows the application to reserve part of its experience for users with confirmed email addresses. Email verification adds the emailVerified key to the ParseUser object. When a ParseUser's email is set or modified, emailVerified is set to false. Parse then emails the user a link which will set emailVerified to true.

There are three emailVerified states to consider:

true - the user confirmed his or her email address by clicking on the link Parse emailed them. ParseUsers can never have a true value when the user account is first created.
false - at the time the ParseUser object was last refreshed, the user had not confirmed his or her email address. If emailVerified is false, consider calling refresh() on the ParseUser.
missing - the ParseUser was created when email verification was off or the ParseUser does not have an email.
Current User

It would be bothersome if the user had to log in every time they open your app. You can avoid this by using the cached currentUser object.

Whenever you use any signup or login methods, the user is cached on disk. You can treat this cache as a session, and automatically assume the user is logged in:

ParseUser currentUser = ParseUser.getCurrentUser();
if (currentUser != null) {
  // do stuff with the user
} else {
  // show the signup or login screen
}
You can clear the current user by logging them out:

ParseUser.logOut();
ParseUser currentUser = ParseUser.getCurrentUser(); // this will now be null
Anonymous Users

Being able to associate data and objects with individual users is highly valuable, but sometimes you want to be able to do this without forcing a user to specify a username and password.

An anonymous user is a user that can be created without a username and password but still has all of the same capabilities as any other ParseUser. After logging out, an anonymous user is abandoned, and its data is no longer accessible.

You can create an anonymous user using ParseAnonymousUtils:

ParseAnonymousUtils.logIn(new LogInCallback() {
  @Override
  public void done(ParseUser user, ParseException e) {
    if (e != null) {
      Log.d("MyApp", "Anonymous login failed.");
    } else {
      Log.d("MyApp", "Anonymous user logged in.");
    }
  }
});
You can convert an anonymous user into a regular user by setting the username and password, then calling signUp(), or by logging in or linking with a service like Facebook or Twitter. The converted user will retain all of its data. To determine whether the current user is an anonymous user, you can check ParseAnonymousUtils.isLinked():

if (ParseAnonymousUtils.isLinked(ParseUser.getCurrentUser())) {
  enableSignUpButton();
} else {
  enableLogOutButton();
}
Anonymous users can also be automatically created for you without requiring a network request, so that you can begin working with your user immediately when your application starts. When you enable automatic anonymous user creation at application startup, ParseUser.getCurrentUser() will never be null. The user will automatically be created in the cloud the first time the user or any object with a relation to the user is saved. Until that point, the user's object ID will be null. Enabling automatic user creation makes associating data with your users painless. For example, in your Application.onCreate() method, you might write:

ParseUser.enableAutomaticUser();
ParseUser.getCurrentUser().increment("RunCount");
ParseUser.getCurrentUser().saveInBackground();
Security For User Objects

The ParseUser class is secured by default. Data stored in a ParseUser can only be modified by that user. By default, the data can still be read by any client. Thus, some ParseUser objects are authenticated and can be modified, whereas others are read-only.

Specifically, you are not able to invoke any of the save or delete type methods unless the ParseUser was obtained using an authenticated method, like logIn or signUp. This ensures that only the user can alter their own data.

The following illustrates this security policy:

ParseUser user = ParseUser.logIn("my_username", "my_password");
user.setUsername("my_new_username"); // attempt to change username
user.saveInBackground(); // This succeeds, since the user was authenticated on the device
 
// Get the user from a non-authenticated manner
ParseQuery query = ParseUser.getQuery();
query.getInBackground(user.getObjectId(), new GetCallback() {
  public void done(ParseObject object, ParseException e) {
    ParseUser userFromQuery = (ParseUser) object;
    userFromQuery.setUsername("another_username");
 
    // This will throw an exception, since the ParseUser is not authenticated
    userFromQuery.saveInBackground();
  }
});
The ParseUser obtained from getCurrentUser() will always be authenticated.

If you need to check if a ParseUser is authenticated, you can invoke the isAuthenticated() method. You do not need to check isAuthenticated() with ParseUser objects that are obtained via an authenticated method.

Security for Other Objects

The same security model that applies to the ParseUser can be applied to other objects. For any object, you can specify which users are allowed to read the object, and which users are allowed to modify an object. To support this type of security, each object has an access control list, implemented by the ParseACL class.

The simplest way to use a ParseACL is to specify that an object may only be read or written by a single user. To create such an object, there must first be a logged in ParseUser. Then, new ParseACL(user) generates a ParseACL that limits access to that user. An object's ACL is updated when the object is saved, like any other property. Thus, to create a private note that can only be accessed by the current user:

ParseObject privateNote = new ParseObject("Note");
privateNote.put("content", "This note is private!");
privateNote.setACL(new ParseACL(ParseUser.getCurrentUser()));
privateNote.saveInBackground();
This note will then only be accessible to the current user, although it will be accessible to any device where that user is signed in. This functionality is useful for applications where you want to enable access to user data across multiple devices, like a personal todo list.

Permissions can also be granted on a per-user basis. You can add permissions individually to a ParseACL using setReadAccess and setWriteAccess. For example, let's say you have a message that will be sent to a group of several users, where each of them have the rights to read and delete that message:

ParseObject groupMessage = new ParseObject("Message");
ParseACL groupACL = new ParseACL();
     
// userList is an Iterable<ParseUser> with the users we are sending this message to.
for (ParseUser user : userList) {
  groupACL.setReadAccess(user, true);
  groupACL.setWriteAccess(user, true);  
}
 
groupMessage.setACL(groupACL);
groupMessage.saveInBackground();
You can also grant permissions to all users at once using setPublicReadAccess and setPublicWriteAccess. This allows patterns like posting comments on a message board. For example, to create a post that can only be edited by its author, but can be read by anyone:

ParseObject publicPost = new ParseObject("Post");
ParseACL postACL = new ParseACL(ParseUser.getCurrentUser());
postACL.setPublicReadAccess(true);
publicPost.setACL(postACL);
publicPost.saveInBackground();
To help ensure that your users' data is secure by default, you can set a default ACL to be applied to all newly-created ParseObjects:

ParseACL.setDefaultACL(defaultACL, true);
In the code above, the second parameter to setDefaultACL tells Parse to ensure that the default ACL assigned at the time of object creation allows read and write access to the current user at that time. Without this setting, you would need to reset the defaultACL every time a user logs in or out so that the current user would be granted access appropriately. With this setting, you can ignore changes to the current user until you explicitly need to grant different kinds of access.

Default ACLs make it easy to create apps that follow common access patterns. An application like Twitter, for example, where user content is generally visible to the world, might set a default ACL such as:

ParseACL defaultACL = new ParseACL();
defaultACL.setPublicReadAccess(true);
ParseACL.setDefaultACL(defaultACL, true);
For an application like Dropbox, where a user's data is only accessible by the user itself unless explicit permission is given, you would provide a default ACL where only the current user is given access:

ParseACL.setDefaultACL(new ParseACL(), true);
An application that logs data to Parse but doesn't provide any user access to that data would instead deny access to the current user while providing a restrictive ACL:

ParseACL.setDefaultACL(new ParseACL(), false);
Operations that are forbidden, such as deleting an object that you do not have write access to, result in a ParseException.OBJECT_NOT_FOUND error code. For security purposes, this prevents clients from distinguishing which object ids exist but are secured, versus which object ids do not exist at all.

Resetting Passwords

It's a fact that as soon as you introduce passwords into a system, users will forget them. In such cases, our library provides a way to let them securely reset their password.

To kick off the password reset flow, ask the user for their email address, and call:

ParseUser.requestPasswordResetInBackground("myemail@example.com",
                                           new RequestPasswordResetCallback() {
  public void done(ParseException e) {
    if (e == null) {
      // An email was successfully sent with reset instructions.
    } else {
      // Something went wrong. Look at the ParseException to see what's up.
    }
  }
});
This will attempt to match the given email with the user's email or username field, and will send them a password reset email. By doing this, you can opt to have users use their email as their username, or you can collect it separately and store it in the email field.

The flow for password reset is as follows:

User requests that their password be reset by typing in their email.
Parse sends an email to their address, with a special password reset link.
User clicks on the reset link, and is directed to a special Parse page that will allow them type in a new password.
User types in a new password. Their password has now been reset to a value they specify.
Note that the messaging in this flow will reference your app by the name that you specified when you created this app on Parse.

Querying

To query for users, you need to use the special user query:

ParseQuery query = ParseUser.getQuery();
query.whereEqualTo("gender", "female");
query.findInBackground(new FindCallback() {
  public void done(List<ParseObject> objects, ParseException e) {
    if (e == null) {
        // The query was successful.
    } else {
        // Something went wrong.
    }
  }
});
In addition, you can use get to get a ParseUser by id.

Associations

Associations involving a ParseUser work right of the box. For example, let's say you're making a blogging app. To store a new post for a user and retrieve all their posts:

ParseUser user = ParseUser.getCurrentUser();
 
// Make a new post
ParseObject post = new ParseObject("Post");
post.put("title", "My New Post");
post.put("body", "This is some great content.");
post.put("user", user);
post.saveInBackground();
 
// Find all posts by the current user
ParseQuery query = new ParseQuery("Post");
query.whereEqualTo("user", user);
query.findInBackground(new FindCallback() { ... });
Users in the Data Browser

The User class is a special class that is dedicated to storing ParseUser objects. In the data browser, you'll see a little person icon next to the User class:



Roles

As your app grows in scope and user-base, you may find yourself needing more coarse-grained control over access to pieces of your data than user-linked ACLs can provide. To address this requirement, Parse supports a form of Role-based Access Control. Roles provide a logical way of grouping users with common access privileges to your Parse data. Roles are named objects that contain users and other roles. Any permission granted to a role is implicitly granted to its users as well as to the users of any roles that it contains.

For example, in your application with curated content, you may have a number of users that are considered "Moderators" and can modify and delete content created by other users. You may also have a set of users that are "Administrators" and are allowed all of the same privileges as Moderators, but can also modify the global settings for the application. By adding users to these roles, you can ensure that new users can be made moderators or administrators, without having to manually grant permission to every resource for each user.

We provide a specialized class called ParseRole that represents these role objects in your client code. ParseRole is a subclass of ParseObject, and has all of the same features, such as a flexible schema, automatic persistence, and a key value interface. All the methods that are on ParseObject also exist on ParseRole. The difference is that ParseRole has some additions specific to management of roles.

Properties

ParseRole has several properties that set it apart from ParseObject:

name: The name for the role. This value is required, and can only be set once as a role is being created. The name must consist of alphanumeric characters, spaces, -, or _. This name will be used to identify the Role without needing its objectId.
users: A relation to the set of users that will inherit permissions granted to the containing role.
roles: A relation to the set of roles whose users and roles will inherit permissions granted to the containing role.
Security for Role Objects

The ParseRole uses the same security scheme (ACLs) as all other objects on Parse, except that it requires an ACL to be set explicitly. Generally, only users with greatly elevated privileges (e.g. a master user or Administrator) should be able to create or modify a Role, so you should define its ACLs accordingly. Remember, if you give write-access to a ParseRole to a user, that user can add other users to the role, or even delete the role altogether.

To create a new ParseRole, you would write:

// By specifying no write privileges for the ACL, we can ensure the role cannot be altered.
ParseACL roleACL = new ParseACL();
roleACL.setPublicReadAccess(true);
ParseRole role = new ParseRole("Administrator", roleACL);
role.saveInBackground();
You can add users and roles that should inherit your new role's permissions through the "users" and "roles" relations on ParseRole:

ParseRole role = new ParseRole(roleName, roleACL);
for (ParseUser user : usersToAddToRole) {
  role.getUsers().add(user)
}
for (ParseRole childRole : rolesToAddToRole) {
  role.getRoles().add(childRole);
}
role.saveInBackground();
Take great care when assigning ACLs to your roles so that they can only be modified by those who should have permissions to modify them.

Security for Other Objects

Now that you have created a set of roles for use in your application, you can use them with ACLs to define the privileges that their users will receive. Each ParseObject can specify a ParseACL, which provides an access control list that indicates which users and roles should be granted read or write access to the object.

Giving a role read or write permission to an object is straightforward. You can either use the ParseRole:

ParseRole moderators = /* Query for some ParseRole */;
ParseObject wallPost = new ParseObject("WallPost");
ParseACL postACL = new ParseACL();
postACL.setRoleWriteAccess(moderators);
wallPost.setACL(postACL);
wallPost.saveInBackground();
You can avoid querying for a role by specifying its name for the ACL:

ParseObject wallPost = new ParseObject("WallPost");
ParseACL postACL = new ParseACL();
postACL.setRoleWriteAccess("Moderators", true);
wallPost.setACL(postACL);
wallPost.save();
Role-based ParseACLs can also be used when specifying default ACLs for your application, making it easy to protect your users' data while granting access to users with additional privileges. For example, a moderated forum application might specify a default ACL like this:

ParseACL defaultACL = new ParseACL();
// Everybody can read objects created by this user
defaultACL.setPublicReadAccess(true);
// Moderators can also modify these objects
defaultACL.setRoleWriteAccess("Moderators");
// And the user can read and modify its own objects
ParseACL.setDefaultACL(defaultACL, true);
Role Hierarchy

As described above, one role can contain another, establishing a parent-child relationship between the two roles. The consequence of this relationship is that any permission granted to the parent role is implicitly granted to all of its child roles.

These types of relationships are commonly found in applications with user-managed content, such as forums. Some small subset of users are "Administrators", with the highest level of access to tweaking the application's settings, creating new forums, setting global messages, and so on. Another set of users are "Moderators", who are responsible for ensuring that the content created by users remains appropriate. Any user with Administrator privileges should also be granted the permissions of any Moderator. To establish this relationship, you would make your "Administrators" role a child role of "Moderators", like this:

ParseRole administrators = /* Your "Administrators" role */;
ParseRole moderators = /* Your "Moderators" role */;
moderators.getRoles().add(administrators);
moderators.saveInBackground();
Role Quotas

Role-based access control is a premium feature of the Parse platform. If you are on the "Basic" plan are limited to 1 custom role, which you can use to protect access for most basic applications that need broader security groups. Parse will not allow you to exceed this quota by accident, preventing you from creating new Roles until you upgrade your plan.

If your current plan is "Pro" or above, you will have an allotment of roles included with your package, and creating Roles exceeding this quota will result in additional charges.

For more information, please see our Plans page.

Facebook Users

Parse provides an easy way to integrate Facebook with your application. The Facebook SDK is included with our SDK, and is integrates with the ParseUser class to make linking your users to their Facebook identities easy.

Using our Facebook integration, you can associate an authenticated Facebook user with a ParseUser. With just a few lines of code, you'll be able to provide a "log in with Facebook" option in your app, and be able to save their data to Parse.

Setup

To start using Facebook with Parse, you need to:

Set up a Facebook app, if you haven't already.
Add your application's Facebook Application ID on your Parse application's settings page.
Add the following where you initialize the Parse SDK in your Application.onCreate()
ParseFacebookUtils.initialize("YOUR FACEBOOK APP ID");
If you encounter any issues that are Facebook-related, a good resource is the official getting started guide from Facebook.

Note that if you already have the Facebook SDK installed in your app, our version of the Facebook SDK will happily work alongside it. Read more about the compatibility issues.

There are two main ways to use Facebook with your Parse users: (1) logging in as a Facebook user and creating a ParseUser, or (2) linking Facebook to an existing ParseUser.

Login & Signup

ParseFacebookUtils provides a way to allow your ParseUsers to log in or sign up through Facebook. This is accomplished using the logIn() method:

ParseFacebookUtils.logIn(this, new LogInCallback() {
  @Override
  public void done(ParseUser user, ParseException err) {
    if (user == null) {
      Log.d("MyApp", "Uh oh. The user cancelled the Facebook login.");
    } else if (user.isNew()) {
      Log.d("MyApp", "User signed up and logged in through Facebook!");
    } else {
      Log.d("MyApp", "User logged in through Facebook!");
    }
  }
});
When this code is run, the following happens:

The user is shown the Facebook login dialog.
The user authenticates via Facebook, and your app receives a callback.
Our SDK receives the Facebook data and saves it to a ParseUser. If it's a new user based on the Facebook ID, then that user is created.
Your LogInCallback is called with the user.
In order to display the Facebook login dialogs and activities, the current Activity must be provided (often, the current activity is this when calling logIn() from within the Activity) as we have done above.

You may optionally provide a collection of strings that specifies what permissions your app requires from the Facebook user. You may specify these strings yourself, or use the constants we've provided for you in the ParseFacebookUtils.Permissions class. For example:

ParseFacebookUtils.logIn(Arrays.asList("create_event", Permissions.Extended.OFFLINE_ACCESS),
        this, new LogInCallback() {
  @Override
  public void done(ParseUser user, ParseException err) {
    // Code to handle login.
  }
});
ParseUser integration doesn't require any permissions to work out of the box (ie. null or specifying no permissions is perfectly acceptable). Read more about permissions on Facebook's developer guide.

It is up to you to record any data that you need from the Facebook user after they authenticate. To accomplish this, you'll need to do a graph query via Facebook's SDK.
Linking

If you want to associate an existing ParseUser to a Facebook account, you can link it like so:

if (!ParseFacebookUtils.isLinked(user)) {
  ParseFacebookUtils.link(user, this, new SaveCallback() {
    @Override
    public void done(ParseException ex) {
      if (ParseFacebookUtils.isLinked(user)) {
        Log.d("MyApp", "Woohoo, user logged in with Facebook!");
      }
    }
  });
}
The steps that happen when linking are very similar to log in. The difference is that on successful login, the existing ParseUser is updated with the Facebook information. Future logins via Facebook will now log the user into their existing account.

If you want to unlink Facebook from a user, simply do this:

ParseFacebookUtils.unlinkInBackground(user, new SaveCallback() {
  @Override
  public void done(ParseException ex) {
    if (ex == null) {
      Log.d("MyApp", "The user is no longer associated with their Facebook account.");
    }
  }
});
Or if you are handling threading yourself, you can call unlink() directly like this:

try {
  ParseFacebookUtils.unlink(user);
  Log.d("MyApp", "The user is no longer associated with their Facebook account.");
} catch (ParseException e) {
}
Enabling Single Sign-on

Facebook's Android SDK provides an enhanced login experience on devices that have Facebook's official Android app installed. This allows users of apps that support Facebook login to sign in directly through the Facebook app, using credentials that are already on the device. If the Facebook app is not installed, the default dialog-based authentication will be used. Facebook calls this feature "Single sign-on," and it can be enabled in the Parse SDK by making the following modifications to your code:

Enable single sign-on in your ParseFacebookUtils.initialize() call.
ParseFacebookUtils.initialize("YOUR FACEBOOK APP ID", true);
Override onActivityResult() in your calling Activity to invoke finishAuthentication().
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
  super.onActivityResult(requestCode, resultCode, data);
  ParseFacebookUtils.finishAuthentication(requestCode, resultCode, data);
}
If your Activity is already using onActivityResult(), you can avoid requestCode collisions by calling the versions of link() and logIn() that take an activityCode parameter and specifying a code you know to be unique. Otherwise, a sensible default activityCode will be used.

Facebook SDK and Parse

The Facebook Android SDK provides a main Facebook object that is the starting point for many of the interactions with Facebook's API. You can read more about their SDK here.

The Parse SDK includes the entire Facebook SDK. All the classes are in the com.parse.facebook package to avoid conflicts with existing libraries. So, for example, the main Facebook object class in our SDK is com.parse.facebook.Facebook.

Our library also manages the Facebook object for you. You can simply call ParseFacebookUtils.getFacebook() to access the singleton instance.

The Facebook singleton is synchronized with the current user by default, so any methods you call on it will be acting on the Facebook user associated with the current ParseUser. Modifying the singleton (by calling any of the set_____() methods) will cause the SDK to fall out of sync with the singleton, and is not recommended.

Compatibility

Even if you already have the Facebook SDK in your project, there should not be any conflicts because our version is located in the com.parse.facebook package. However, we recommend that you alter all references in your application to use our version and remove your version of the Facebook SDK in order to avoid unnecessary duplication and naming collisions.

Twitter Users

As with Facebook, Parse also provides an easy way to integrate Twitter authentication into your application. The Parse SDK provides a straightforward way to authorize and link a Twitter account to your ParseUsers. With just a few lines of code, you'll be able to provide a "log in with Twitter" option in your app, and be able to save their data to Parse.

Setup

To start using Twitter with Parse, you need to:

Set up a Twitter app, if you haven't already.
Add your application's Twitter consumer key on your Parse application's settings page.
When asked to specify a "Callback URL" for your Twitter app, please insert a valid URL. This value will not be used by your iOS or Android application, but is necessary in order to enable authentication through Twitter.
Add the following where you initialize the Parse SDK in your Application.onCreate()
ParseTwitterUtils.initialize("YOUR CONSUMER KEY", "YOUR CONSUMER SECRET");
If you encounter any issues that are Twitter-related, a good resource is the official Twitter documentation.

There are two main ways to use Twitter with your Parse users: (1) logging in as a Twitter user and creating a ParseUser, or (2) linking Twitter to an existing ParseUser.

Login & Signup

ParseTwitterUtils provides a way to allow your ParseUsers to log in or sign up through Twitter. This is accomplished using the logIn() method:

ParseTwitterUtils.logIn(this, new LogInCallback() {
  @Override
  public void done(ParseUser user, ParseException err) {
    if (user == null) {
      Log.d("MyApp", "Uh oh. The user cancelled the Twitter login.");
    } else if (user.isNew()) {
      Log.d("MyApp", "User signed up and logged in through Twitter!");
    } else {
      Log.d("MyApp", "User logged in through Twitter!");
    }
  }
});
When this code is run, the following happens:

The user is shown the Twitter login dialog.
The user authenticates via Twitter, and your app receives a callback.
Our SDK receives the Twitter data and saves it to a ParseUser. If it's a new user based on the Twitter handle, then that user is created.
Your LogInCallback is called with the user.
In order to display the Twitter login dialogs and activities, the current Context must be provided (often, the current context is this when calling logIn() from within the Activity) as we have done above.

Linking

If you want to associate an existing ParseUser with a Twitter account, you can link it like so:

if (!ParseTwitterUtils.isLinked(user)) {
  ParseTwitterUtils.link(user, this, new SaveCallback() {
    @Override
    public void done(ParseException ex) {
      if (ParseTwitterUtils.isLinked(user)) {
        Log.d("MyApp", "Woohoo, user logged in with Twitter!");
      }
    }
  });
}
The steps that happen when linking are very similar to log in. The difference is that on successful login, the existing ParseUser is updated with the Twitter information. Future logins via Twitter will now log the user into their existing account.

If you want to unlink Twitter from a user, simply do this:

ParseTwitterUtils.unlinkInBackground(user, new SaveCallback() {
  @Override
  public void done(ParseException ex) {
    if (ex == null) {
      Log.d("MyApp", "The user is no longer associated with their Twitter account.");
    }
  }
});
Twitter API Calls

Our SDK provides a straightforward way to sign your API HTTP requests to the Twitter REST API when your app has a Twitter-linked ParseUser. To make a request through our API, you can use the Twitter singleton provided by ParseTwitterUtils:

HttpClient client = new DefaultHttpClient();
HttpGet verifyGet = new HttpGet(
        "https://api.twitter.com/1/account/verify_credentials.json");
ParseTwitterUtils.getTwitter().signRequest(verifyGet);
HttpResponse response = client.execute(verifyGet);
GeoPoints

Parse allows you to associate real-world latitude and longitude coordinates with an object. Adding a ParseGeoPoint to a ParseObject allows queries to take into account the proximity of an object to a reference point. This allows you to easily do things like find out what user is closest to another user or which places are closest to a user.

ParseGeoPoint

To associate a point with an object you first need to create a ParseGeoPoint. For example, to create a point with latitude of 40.0 degrees and -30.0 degrees longitude:

ParseGeoPoint point = new ParseGeoPoint(40.0, -30.0);
This point is then stored in the object as a regular field.

placeObject.put("location", point);
Geo Queries

Now that you have a bunch of objects with spatial coordinates, it would be nice to find out which objects are closest to a point. This can be done by adding another restriction to ParseQuery using whereNear. Getting a list of ten places that are closest to a user may look something like:

ParseGeoPoint userLocation = (ParseGeoPoint) userObject.get("location");
ParseQuery query = new ParseQuery("PlaceObject");
query.whereNear("location", userLocation);
query.setLimit(10);
query.findInBackground(new FindCallback() { ... });
At this point nearPlaces will be an array of objects ordered by distance (nearest to farthest) from userLocation.

To limit the results using distance, check out whereWithinKilometers, whereWithinMiles, and whereWithinRadians.

It's also possible to query for the set of objects that are contained within a particular area. To find the objects in a rectangular bounding box, add the whereWithinGeoBox restriction to your ParseQuery.

ParseGeoPoint southwestOfSF = new ParseGeoPoint(37.708813, -122.526398);
ParseGeoPoint northeastOfSF = new ParseGeoPoint(37.822802, -122.373962);
ParseQuery query = new ParseQuery("PizzaPlaceObject");
query.whereWithinGeoBox("location", southwestOfSF, northeastOfSF);
query.findInBackground(new FindCallback() { ... });
Caveats

At the moment there are a couple of things to watch out for:

Each ParseObject class may only have one key with a ParseGeoPoint object.
Points should not equal or exceed the extreme ends of the ranges. Latitude should not be -90.0 or 90.0. Longitude should not be -180.0 or 180.0. Attempting to set latitude or longitude out of bounds will cause an error.
Handling Errors

Many of the methods on ParseObject, including save(), delete(), and get() will throw a ParseException on an invalid request, such as deleting or editing an object that no longer exists in the cloud, or when there is a network failure preventing communication with the Parse Cloud. You will need to catch and deal with these exceptions.

For more details, look at the Android API.

Security

We strongly recommend that you build your applications to restrict access to data as much as possible. With this in mind, we recommend that you enable automatic anonymous user creation and specify a default ACL based upon the current user when your application is initialized. Explicitly set public writability (and potentially public readability) on an object-by-object basis in order to protect your data from unauthorized access.

Consider adding the following code to your application startup:

ParseUser.enableAutomaticUser();
ParseACL defaultACL = new ParseACL();
// Optionally enable public read access while disabling public write access.
// defaultACL.setPublicReadAccess(true);
ParseACL.setDefaultACL(defaultACL, true);
Please keep secure access to your data in mind as you build your applications for the protection of both you and your users.

Settings

In addition to coding securely, please review the settings pages for your applications to select options that will restrict access to your applications as much as is appropriate for your needs. For example, if users should be unable to log in without a Facebook account linked to their application, disable all other login mechanisms. Specify your Facebook application IDs, Twitter consumer keys, and other such information to enable server-side validation of your users' login attempts.

Data & Security

Data

Valid Data Types

We've designed the Parse SDKs so that you typically don't need to worry about how data is saved while using the iOS or Android SDKs. Simply add data to the PFObject or ParseObject, and it'll be saved correctly.

Nevertheless, there are some cases where it's useful to be aware of how data is stored on the Parse platform.

Internally, Parse stores data as JSON, so any datatype that can be converted to JSON can be stored on Parse. The framework can also handle Date, Bytes, and File types. Overall, the following types are allowed for each field in your object:

String
Number
Boolean
Array
Object
Date
Bytes
File
Null
The type Object simply denotes that each value can be composed of nested objects that are JSON-encodable. Keys including the characters $ or ., along with the key __type key, are reserved for the framework to handle additional types, so don't use those yourself.

Our SDK handles translating native Objective-C and Java types to JSON. For example, if you save an NSString object, it will be translated into a String type in our system.

There are two ways to store binary data. The Bytes type allows you to associate NSData/bytes[] types directly on a PFObject. This is recommended only for small pieces of binary-encoded data. For actual files (images, documents, etc.), the File type can be used by instantiating a PFFile/ParseFile and setting it on a field.

Data Type Lock-in

When a class is initially created, it doesn't have an inherent schema defined. This means that for the first object, it could have any types of fields you want.

However, after a field has been set at least once, that field is locked into the particular type that was saved. For example, if a User object is saved with field name of type String, that field will be restricted to the String type only (our SDK will return an error if you try to save anything else).

One special case is that any field can be set to null, no matter what type it is.

The Data Browser

The Data Browser is the web UI where you can update and create objects in each of your apps. Here, you can see the raw JSON values that are saved that represents each object in your class.

When using the interface, keep in mind the following:

Entering "null" will set the value to the special null value, not the string "null".
The objectId, createdAt, updatedAt fields cannot be edited (these are set automatically).
The value "(empty)" denotes that the field has not been set for that particular object (this is different than null).
Importing Data

In addition to the REST api, we also offer data import through CSV files.

To create a new class with data from a CSV file, go to the Data Browser and click the "Import" button on the left hand column.

Security

For any mobile application, since the client code runs on a mobile device, it's possible that an untrustworthy client could edit that code and issue malicious requests. Choosing the right way to secure your application is important, but the right way to do it depends on your application and the types of data it stores.

Parse offers several ways to use permissions to enforce security. If you have questions around how best to secure your application, we encourage you to contact feedback@parse.com.

Object-Level Permissions

The most flexible way to secure application data is through access control lists, commonly known as ACLs. The idea behind an ACL is that each object has a list of users and roles along with what permissions that user or role has. A user needs read permissions (or must belong to a role that has read permissions) in order to retrieve an object's data, and a user needs write permissions (or must belong to a role that has right permissions) in order to update or delete that object.

Most applications can enforce their access patterns through ACLs. For example:

For private data, "read" and "write" access can be restricted to the owner.
For a post on a message board, the author and members of the "Moderators" role can have "write" access, and the general public can have "read" access.
For logging data that will only be accessed by the developer through the REST API, the ACL can deny all permissions.
Data created by a privileged group of users or the developer, like a global message of the day, can have public "read" access but restrict "write" access to an "Administrators" role.
A message sent from one user to another can give "read" and "write" access just to those users.
Using the Parse SDKs, you can set a default ACL for all of the objects your application clients creates. If you also enable automatic anonymous user creation for your application, you can ensure that your data has ACLs restricted to individual users by default. See the iOS and Android guides for more information about choosing secure defaults.

All operations are still possible when authenticating with the master key via the REST API. As a developer, this lets you manage any aspect of the data. For example, you can delete private messages via the REST API even if they are private based on the ACL.

For code examples on how to use ACLs, see the ACL section of the iOS Guide and the ACL section of the Android Guide.

Class-Level Permissions

For some situations, it is more natural to specify for an entire class which permissions are allowed. For example, you might want an entire class to be read-only, or write-only.

To make this easier, Parse lets you specify what operations are allowed per class. To access these settings, go to the Data Browser, select a class, and click the "Settings" button on the right hand side.

You can disable the client's ability to perform each of the following operations for the selected class:

Get - fetching an object by its objectId.
Find - issuing a query to fetch objects.
Update - saving an object that already exists and has been modified.
Create - saving an object that is new and hasn't been created yet.
Delete - deleting an object.
Add fields - adding fields to the class.
You can also disable creation of new classes altogether by going to the "Settings" panel, and turning off "Allow client class creation" on the "General Settings" tab.

If you haven't installed the SDK yet, please head over to the QuickStart guide to get our SDK up and running in Xcode.

The Parse platform provides a complete backend solution for your mobile application. Our goal is to totally eliminate the need for writing server code or maintaining servers.

If you're familiar with web frameworks like Ruby on Rails, we've taken many of the same principles and applied them to our platform. In particular, our SDK is ready to use out of the box with minimal configuration on your part.

On Parse, you create an App for each of your mobile applications. Each App has its own application id and client key that you apply to your SDK install. Your account on Parse can accommodate multiple Apps. This is useful even if you have one application, since you can deploy different versions for test and production.

Storing data on Parse is built around the PFObject. Each PFObject contains key-value pairs of JSON-compatible data. This data is schemaless, which means that you don't need to specify ahead of time what keys exist on each PFObject. You simply set whatever key-value pairs you want, and our backend will store it.

For example, let's say you're tracking high scores for a game. A single PFObject could contain:

score: 1337, playerName: "Sean Plott", cheatMode: false
Keys must be alphanumeric strings. Values can be strings, numbers, booleans, or even arrays and dictionaries - anything that can be JSON-encoded.

Each PFObject has a class name that you can use to distinguish different sorts of data. For example, we could call the high score object a GameScore. We recommend that you NameYourClassesLikeThis and nameYourKeysLikeThis, just to keep your code looking pretty.

Let's say you want to save the GameScore described above to the Parse Cloud. The interface is similar to a NSMutableDictionary, plus the save method:

PFObject *gameScore = [PFObject objectWithClassName:@"GameScore"];
[gameScore setObject:[NSNumber numberWithInt:1337] forKey:@"score"];
[gameScore setObject:@"Sean Plott" forKey:@"playerName"];
[gameScore setObject:[NSNumber numberWithBool:NO] forKey:@"cheatMode"];
[gameScore save];
After this code runs, you will probably be wondering if anything really happened. To make sure the data was saved, you can look at the Data Browser in your app on Parse. You should see something like this:

objectId: "xWMyZ4YEGZ", score: 1337, playerName: "Sean Plott", cheatMode: false,
createdAt:"2011-06-10T18:33:42Z", updatedAt:"2011-06-10T18:33:42Z"

There are two things to note here. You didn't have to configure or set up a new Class called GameScore before running this code. Your Parse app lazily creates this Class for you when it first encounters it.

There are also a few fields you don't need to specify that are provided as a convenience. objectId is a unique identifier for each saved object. createdAt and updatedAt represent the time that each object was created and last modified in the Parse Cloud. Each of these fields is filled in by Parse, so they don't exist on a PFObject until a save operation has completed.


Saving data to the cloud is fun, but it's even more fun to get that data out again. If you have the objectId, you can retrieve the whole PFObject using a PFQuery:

PFQuery *query = [PFQuery queryWithClassName:@"GameScore"];
PFObject *gameScore = [query getObjectWithId:@"xWMyZ4YEGZ"];
To get the values out of the PFObject, use the objectForKey: method.

int score = [[gameScore objectForKey:@"score"] intValue];
NSString *playerName = [gameScore objectForKey:@"playerName"];
BOOL cheatMode = [[gameScore objectForKey:@"cheatMode"] boolValue];
The three special values are provided as properties:

NSString *objectId = gameScore.objectId;
NSDate *updatedAt = gameScore.updatedAt;
NSDate *createdAt = gameScore.createdAt;
If you need to refresh an object you already have with the latest data that is in the Parse Cloud, you can call the refresh method like so:

[myObject refresh];

On the iOS platform, most code is run on the main thread. However, if you access the network on the main thread, your app can freeze or sometimes crash.

The save and getObjectWithId: methods we've seen so far make a network access, so they should not be run on the main thread. It's annoying to deal with threads yourself, so the Parse library provides helper functions that should be used in most cases. For example, to save our previous PFObject in a background thread, just use saveInBackground instead of save:

[gameScore saveInBackground];
The saveInBackground call will return immediately, so the main thread will not be blocked, and the app remains responsive.

Often, we want to run code when an operation completes. You can either use blocks (if you target iOS 4.0+) or callback methods. For example, if you wanted to run code once this save was complete:

[gameScore saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
  if (!error) {
    // The gameScore saved successfully.
  } else {
    // There was an error saving the gameScore.
  }
}];
blockscallbacks
Parse ensures that the network access does not block the calling thread, while the block or callback happens on the main thread. This means that the network access will not freeze the UI, but you can still manipulate the UI from the callback.

PFQuery also follows the same pattern. For example, to fetch and log the score from our GameScore object without blocking the main thread:

PFQuery *query = [PFQuery queryWithClassName:@"GameScore"];
[query getObjectInBackgroundWithId:@"xWMyZ4YEGZ"
                             block:^(PFObject *gameScore, NSError *error) {
  if (!error) {
    // The get request succeeded. Log the score
    NSLog(@"The score was: %d", [[gameScore objectForKey:@"score"] intValue]);
  } else {
    // Log details of our failure
    NSLog(@"Error: %@ %@", error, [error userInfo]);
  }
}];
blockscallbacks
Saving Objects Offline

Most save functions execute immediately, and inform your app when the save is complete. If you don't need to know when the save has finished, you can use saveEventually instead. The advantage is that if the user currently doesn't have a network connection, saveEventually will store the update on the device until a network connection is re-established. If your app is closed before the connection is back, Parse will try again the next time the app is opened. All calls to saveEventually (and deleteEventually) are executed in the order they are called, so it is safe to call saveEventually on an object multiple times.

// Create the object.
PFObject *gameScore = [PFObject objectWithClassName:@"GameScore"];
[gameScore setObject:[NSNumber numberWithInt:1337] forKey:@"score"];
[gameScore setObject:@"Sean Plott" forKey:@"playerName"];
[gameScore setObject:[NSNumber numberWithBool:NO] forKey:@"cheatMode"];
[gameScore saveEventually];
Updating Objects

Updating an object is simple. Just set some new data on it and call one of the save methods. For example:

// Create the object.
PFObject *gameScore = [PFObject objectWithClassName:@"GameScore"];
[gameScore setObject:[NSNumber numberWithInt:1337] forKey:@"score"];
[gameScore setObject:@"Sean Plott" forKey:@"playerName"];
[gameScore setObject:[NSNumber numberWithBool:NO] forKey:@"cheatMode"];
[gameScore setObject:[NSArray arrayWithObjects:@"pwnage", @"flying", nil] forKey:@"skills"];
[gameScore saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
 
    // Now let's update it with some new data. In this case, only cheatMode and score
    // will get sent to the cloud. playerName hasn't changed.
    [gameScore setObject:[NSNumber numberWithBool:YES] forKey:@"cheatMode"];
    [gameScore setObject:[NSNumber numberWithInt:1338] forKey:@"score"];
    [gameScore saveInBackground];
}];
The client automatically figures out which data has changed so only "dirty" fields will be sent to Parse. You don't need to worry about squashing data that you didn't intend to update.

Counters

The above example contains a common use case. The "score" field is a counter that we'll need to continually update with the player's latest score. Using the above method works but it's cumbersome and can lead to problems if you have multiple clients trying to update the same counter.

To help with storing counter-type data, Parse provides methods that atomically increment (or decrement) any number field. So, the same update can be rewritten as:

[gameScore incrementKey:@"score"];
[gameScore saveInBackground];
You can also increment by any amount using incrementKey:byAmount:.

Arrays

To help with storing array data, there are three operations that can be used to atomically change an array field:

addObject:forKey: and addObjectsFromArray:forKey: append the given objects to the end of an array field.
addUniqueObject:forKey: and addUniqueObjectsFromArray:forKey: add only the given objects which aren't already contained in an array field to that field. The position of the insert is not guaranteed.
removeObject:forKey: and removeObjectsInArray:forKey: remove all instances of each given object from an array field.
For example, we can add items to the set-like "skills" field like so:

[gameScore addUniqueObjectsFromArray:[NSArray arrayWithObjects:@"flying", @"kungfu", nil] forKey:@"skills"];
[gameScore saveInBackground];
Deleting Objects

To delete an object from the cloud:

[myObject deleteInBackground];
If you want to run a callback when the delete is confirmed, you can use the deleteInBackgroundWithBlock: or deleteInBackgroundWithTarget:selector: methods. If you want to block the calling thread, you can use the delete method.

You can delete a single field from an object with the removeObjectForKey method:

// After this, the playerName field will be empty
[myObject removeObjectForKey:@"playerName"];
 
// Saves the field deletion to the Parse Cloud
[myObject saveInBackground];
Relational Data

Objects can have relationships with other objects. To model this behavior, any PFObject can be used as a value in other PFObjects. Internally, the Parse framework will store the referred-to object in just one place, to maintain consistency.

Watch the One-To-Many Relationships tutorial, where you'll learn how to create a one-to-many relationship between two PFObjects in a simple blogging application.
For example, each Comment in a blogging app might correspond to one Post. To create a new Post with a single Comment, you could write:

// Create the post
PFObject *myPost = [PFObject objectWithClassName:@"Post"];
[myPost setObject:@"I'm Hungry" forKey:@"title"];
[myPost setObject:@"Where should we go for lunch?" forKey:@"content"];
 
// Create the comment
PFObject *myComment = [PFObject objectWithClassName:@"Comment"];
[myComment setObject:@"Let's do Sushirrito." forKey:@"content"];
 
// Add a relation between the Post and Comment
[myComment setObject:myPost forKey:@"parent"];
 
// This will save both myPost and myComment
[myComment saveInBackground];
You can also link objects using just their objectIds like so:

[myComment setObject:[PFObject objectWithoutDataWithClassName:@"Post" objectId:@"1zEcyElZ80"] 
              forKey:@"parent"];
By default, when fetching an object, related PFObjects are not fetched. These objects' values cannot be retrieved until they have been fetched like so:

PFObject *post = [fetchedComment objectForKey:@"parent"];
[post fetchIfNeededInBackgroundWithBlock:^(PFObject *object, NSError *error) {
  NSString *title = [post objectForKey:@"title"];
}];
You can also model a many-to-many relation using the PFRelation object. This works similar to an NSArray of PFObjects, except that you don't need to download all the Objects in a relation at once. This allows PFRelation to scale to many more objects than the NSArray of PFObject approach. For example, a User may have many Posts that they might like. In this case, you can store the set of Posts that a User likes using relationforKey:. In order to add a post to the list, the code would look something like:

PFUser *user = [PFUser currentUser];
PFRelation *relation = [user relationforKey:@"likes"];
[relation addObject:post];
[user saveInBackground];
You can remove a post from the PFRelation with something like:

[relation removeObject:post];
By default, the list of objects in this relation are not downloaded. You can get the list of Posts by using calling findObjectsInBackgroundWithBlock: on the PFQuery returned by query. The code would look like:

[[relation query] findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
  if (error) {
     // There was an error
  } else {
    // objects has all the Posts the current user liked.
  }
}];
If you want only a subset of the Posts you can add extra constraints to the PFQuery returned by query like this:

PFQuery *query = [relation query];
// Add other query constraints.
For more details on PFQuery please look at the query portion of this guide. A PFRelation behaves similar to an NSArray of PFObject, so any queries you can do on arrays of objects you can do on PFRelation.

Data Types

So far we've used values with type NSString, NSNumber, and PFObject. Parse also supports NSDate, NSData, and NSNull.

You can nest NSDictionary and NSArray objects to store more structured data within a single PFObject.

Some examples:

NSNumber *number = [NSNumber numberWithInt:42];
NSString *string = [NSString stringWithFormat:@"the number is %i", number];
NSDate *date = [NSDate date];
NSData *data = [@"foo" dataUsingEncoding:NSUTF8StringEncoding];
NSArray *array = [NSArray arrayWithObjects:string, number, nil];
NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:number, @"number",
                                                                      string, @"string",
                                                                      nil];
NSNull *null = [NSNull null];
 
PFObject *bigObject = [PFObject objectWithClassName:@"BigObject"];
[bigObject setObject:number     forKey:@"myNumber"];
[bigObject setObject:string     forKey:@"myString"];
[bigObject setObject:date       forKey:@"myDate"];
[bigObject setObject:data       forKey:@"myData"];
[bigObject setObject:array      forKey:@"myArray"];
[bigObject setObject:dictionary forKey:@"myDictionary"];
[bigObject setObject:null       forKey:@"myNull"];
[bigObject saveInBackground];
We do not recommend storing large pieces of binary data like images or documents using NSData fields on PFObject. PFObjects should not exceed 128 kilobytes in size. To store more, we recommend you use PFFile. See the guide section for more details.

For more information about how Parse handles data, check out our documentation on Data & Security.

Queries

We've already seen how a PFQuery with getObjectWithId: can retrieve a single PFObject from Parse. There are many other ways to retrieve data with PFQuery - you can retrieve many objects at once, put conditions on the objects you wish to retrieve, cache queries automatically to avoid writing that code yourself, and more.
Basic Queries

In many cases, getObjectInBackgroundWithId:block: isn't powerful enough to specify which objects you want to retrieve. The PFQuery offers different ways to retrieve a list of objects rather than just a single object.

The general pattern is to create a PFQuery, put conditions on it, and then retrieve a NSArray of matching PFObjects using either findObjectsInBackgroundWithBlock: or findObjectsInBackgroundWithTarget:selector:. For example, to retrieve scores with a particular playerName, use the whereKey:equalTo: method to constrain the value for a key.

PFQuery *query = [PFQuery queryWithClassName:@"GameScore"];
[query whereKey:@"playerName" equalTo:@"Dan Stemkoski"];
[query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
  if (!error) {
    // The find succeeded.
    NSLog(@"Successfully retrieved %d scores.", objects.count);
  } else {
    // Log details of the failure
    NSLog(@"Error: %@ %@", error, [error userInfo]);
  }
}];
blockscallbacks
Both findObjectsInBackgroundWithBlock: and findObjectsInBackgroundWithTarget:selector: work similarly in that they assure the network request is done without blocking, and run the block/callback in the main thread. There is a corresponding findObjects method that blocks the calling thread, if you are already in a background thread:

// Only use this code if you are already running it in a background
// thread, or for testing purposes!
PFQuery *query = [PFQuery queryWithClassName:@"GameScore"];
[query whereKey:@"playerName" equalTo:@"Dan Stemkoski"];
NSArray* scoreArray = [query findObjects];
Query Constraints

There are several ways to put constraints on the objects found by a PFQuery. You can filter out objects with a particular key-value pair with whereKey:notEqualTo:

[query whereKey:@"playerName" notEqualTo:@"Michael Yabuti"];
You can give multiple constraints, and objects will only be in the results if they match all of the constraints. In other words, it's like an AND of constraints.

[query whereKey:@"playerName" notEqualTo:@"Michael Yabuti"];
[query whereKey:@"playerAge" greaterThan:[NSNumber numberWithInt:18]];
You can limit the number of results by setting limit. By default, results are limited to 100, but anything from 1 to 1000 is a valid limit:

query.limit = 10; // limit to at most 10 results
If you want exactly one result, a more convenient alternative may be to use getFirstObject or getFirstObjectInBackground instead of using findObject.

PFQuery *query = [PFQuery queryWithClassName:@"GameScore"];
[query whereKey:@"playerEmail" equalTo:@"dstemkoski@example.com"];
[query getFirstObjectInBackgroundWithBlock:^(PFObject *object, NSError *error) {
  if (!object) {
    NSLog(@"The getFirstObject request failed.");
  } else {
    // The find succeeded.
    NSLog(@"Successfully retrieved the object.");
  }
}];
blockscallbacks
You can skip the first results by setting skip. This can be useful for pagination:

query.skip = 10; // skip the first 10 results
For sortable types like numbers and strings, you can control the order in which results are returned:

// Sorts the results in ascending order by the score field
[query orderByAscending:@"score"];
 
// Sorts the results in descending order by the score field
[query orderByDescending:@"score"];
You can add more sort keys to the query as follows:

// Sorts the results in ascending order by the score field if the previous sort keys are equal.
[query addAscendingOrder:"score"];
 
// Sorts the results in descending order by the score field if the previous sort keys are equal.
[query addDescendingOrder:"score"];
For sortable types, you can also use comparisons in queries:

// Restricts to wins < 50
[query whereKey:@"wins" lessThan:[NSNumber numberWithInt:50]];
 
// Restricts to wins <= 50
[query whereKey:@"wins" lessThanOrEqualTo:[NSNumber numberWithInt:50]]; 
 
// Restricts to wins > 50
[query whereKey:@"wins" greaterThan:[NSNumber numberWithInt:50]];
 
// Restricts to wins >= 50
[query whereKey:@"wins" greaterThanOrEqualTo:[NSNumber numberWithInt:50]];
If you want to retrieve objects matching several different values, you can use whereKey:containedIn:, providing an array of acceptable values. This is often useful to replace multiple queries with a single query. For example, if you want to retrieve scores made by any player in a particular list:

// Finds scores from any of Jonathan, Dario, or Shawn
NSArray *names = [NSArray arrayWithObjects:@"Jonathan Walsh",
                                           @"Dario Wunsch",
                                           @"Shawn Simon",
                                           nil];
[query whereKey:@"playerName" containedIn:names];
If you want to retrieve objects that do not match any of several values you can use whereKey:notContainedIn:, providing an array of acceptable values. For example, if you want to retrieve scores from players besides those in a list:

// Finds scores from anyone who is neither Jonathan, Dario, nor Shawn
NSArray *names = [NSArray arrayWithObjects:@"Jonathan Walsh",
                                           @"Dario Wunsch",
                                           @"Shawn Simon",
                                           nil];
[query whereKey:@"playerName" notContainedIn:names];
If you want to retrieve objects that have a particular key set, you can use whereKeyExists. Conversely, if you want to retrieve objects without a particular key set, you can use whereKeyDoesNotExist.

// Finds objects that have the score set
[query whereKeyExists:@"score"];
 
// Finds objects that don't have the score set
[query whereKeyDoesNotExist:@"score"];
You can use the whereKey:matchesKey:inQuery: method to get objects where a key matches the value of a key in a set of objects resulting from another query. For example, if you have a class containing sports teams and you store a user's hometown in the user class, you can issue one query to find the list of users whose hometown teams have winning records. The query would look like:

PFQuery *teamQuery = [PFQuery queryWithClassName:@"Team"];
[teamQuery whereKey:@"winPct" greaterThan:[NSNumber withDouble:0.5]];
PFQuery *userQuery = [PFQuery queryForUser];
[userQuery whereKey:@"hometown" matchesKey:@"city" inQuery:teamQuery];
[userQuery findObjectsInBackgroundWithBlock^(NSArray *results, NSError *) {
        // results will contain users with a hometown team with a winning record
}];
Queries on Array Values

For keys with an array type, you can find objects where the key's array value contains 2 by:

// Find objects where the array in arrayKey contains 2.
[query whereKey:@"arrayKey" equalTo:[NSNumber numberWithInt:2]];
Queries on String Values

There are several ways you can search over values containing strings. For any regular expression, you can use whereKey:matchesRegex: to retrieve only the values that match it:

// Finds barbecue sauces that start with a capital letter and a digit.
PFQuery *query = [PFQuery queryWithClassName:@"BarbecueSauce"];
[query whereKey:@"name" matchesRegex:@"^[A-Z]\\d"];
 
[query findObjectsInBackgroundWithBlock:^(NSArray *sauces, NSError *error) {
    // The sauces could have, for example, name = "A1 Steak Sauce"
}];
Parse uses the Perl-compatible regular expression format. Since the regular expression string is escaped by Objective-C before being interpreted by the regular expression engine, be sure that you replace backslashes for the regular expression with double backslashes.

PFQuery also supports modifiers with whereKey:matchesRegex:modifiers:. The supported PCRE modifiers are:
i - Case insensitive search
m - Search across multiple lines of input
// Some people type "BBQ", others type "bbq". Consider them the same thing with the i modifier.
// The m modifier helps us find sauces that call themselves "bbq sauce" after the first line of text.
PFQuery *query = [PFQuery queryWithClassName:@"Sauce"]
[query whereKey:@"description" matchesRegex:@"bbq" modifiers:@"im"];
 
[query findObjectsInBackgroundWithBlock:^(NSArray *sauces, NSError *error) {
    // Sauces that call themselves a "bbq" sauce.
}];
There are also several helper functions for standard string operations: substrings, prefixes, and suffixes. Use whereKey:containsString: to restrict to string values containing a substring:

// Finds barbecue sauces that contain the string "Extra Spicy!".
PFQuery *query = [PFQuery queryWithClassName:@"BarbecueSauce"];
[query whereKey:@"name" containsString:@"Extra Spicy!"];
Use whereKey:hasPrefix: to restrict to string values that start with a particular string. Similar to a MySQL LIKE operator, this is indexed so it is efficient for large datasets:

// Finds barbecue sauces that start with "Big Daddy's".
PFQuery *query = [PFQuery queryWithClassName:@"BarbecueSauce"];
[query whereKey:@"name" hasPrefix:@"Big Daddy's"];
Use whereKey:hasSuffix: to restrict to string values that end with a particular string:

// Finds barbecue sauces that end with "Original Recipe".
PFQuery *query = [PFQuery queryWithClassName:@"BarbecueSauce"];
[query whereKey:@"name" hasSuffix:@"Original Recipe"];
Relational Queries

There are several ways to issue queries for relational data. If you want to retrieve objects where a field matches a particular PFObject, you can use whereKey:equalTo: just like for other data types. For example, if each Comment has a Post object in its post field, you can fetch comments for a particular Post:

// Assume PFObject *myPost was previously created.
PFQuery *query = [PFQuery queryWithClassName:@"Comment"];
[query whereKey:@"post" equalTo:myPost];
 
[query findObjectsInBackgroundWithBlock:^(NSArray *comments, NSError *error) {
    // comments now contains the comments for myPost
}];
You can also do relational queries by objectId:

[query whereKey:@"post"
        equalTo:[PFObject objectWithoutDataWithClassName:@"Post" objectId:@"1zEcyElZ80"]];
If you want to retrieve objects where a field contains a PFObject that match a different query, you can use whereKey:matchesQuery. Note that the default limit of 100 and maximum limit of 1000 apply to the inner query as well, so with large data sets you may need to construct queries carefully to get the desired behavior. In order to find comments for posts with images, you can do:

PFQuery *innerQuery = [PFQuery queryWithClassName:@"Post"];
[innerQuery whereKeyExists:@"image"];
PFQuery *query = [PFQuery queryWithClassName:@"Comment"];
[query whereKey:@"post" matchesQuery:innerQuery];
[query findObjectsInBackgroundWithBlock:^(NSArray *comments, NSError *error) {
    // comments now contains the comments for posts with images
}];
If you want to retrieve objects where a field contains a PFObject that does not match a different query, you can use whereKey:doesNotMatchQuery. In order to find comments for posts without images, you can do:

PFQuery *innerQuery = [PFQuery queryWithClassName:@"Post"];
[innerQuery whereKeyExists:@"image"];
PFQuery *query = [PFQuery queryWithClassName:@"Comment"];
[query whereKey:@"post" doesNotMatchQuery:innerQuery];
[query findObjectsInBackgroundWithBlock:^(NSArray *comments, NSError *error) {
    // comments now contains the comments for posts without images
}];
In some situations, you want to return multiple types of related objects in one query. You can do this with the includeKey: method. For example, let's say you are retrieving the last ten comments, and you want to retrieve their related posts at the same time:

PFQuery *query = [PFQuery queryWithClassName:@"Comment"];
 
// Retrieve the most recent ones
[query orderByDescending:@"createdAt"];
 
// Only retrieve the last ten
query.limit = [NSNumber numberWithInt:10];
 
// Include the post data with each comment
[query includeKey:@"post"];
 
[query findObjectsInBackgroundWithBlock:^(NSArray *comments, NSError *error) {
    // Comments now contains the last ten comments, and the "post" field
    // has been populated. For example:
    for (PFObject *comment in comments) {
         // This does not require a network access.
         PFObject *post = [comment objectForKey:@"post"];
         NSLog(@"retrieved related post: %@", post);
    }
}];
You can also do multi level includes using dot notation. If you wanted to include the post for a comment and the post's author as well you can do:

[query includeKey:@"post.author"];
You can issue a query with multiple fields included by calling includeKey: multiple times. This functionality also works with PFQuery helpers like getFirstObject and getObjectInBackground

Caching Queries

It's often useful to cache the result of a query on disk. This lets you show data when the user's device is offline, or when the app has just started and network requests have not yet had time to complete. Parse takes care of automatically flushing the cache when it takes up too much space.

The default query behavior doesn't use the cache, but you can enable caching by setting query.cachePolicy. For example, to try the network and then fall back to cached data if the network is not available:

PFQuery *query = [PFQuery queryWithClassName:@"GameScore"];
query.cachePolicy = kPFCachePolicyNetworkElseCache;
[query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
  if (!error) {
    // Results were successfully found, looking first on the
    // network and then on disk.
  } else {
    // The network was inaccessible and we have no cached data for
    // this query.
  }
}];
blockscallbacks
Parse provides several different cache policies:

kPFCachePolicyIgnoreCache 
The query does not load from the cache or save results to the cache. kPFCachePolicyIgnoreCache is the default cache policy.
kPFCachePolicyCacheOnly 
The query only loads from the cache, ignoring the network. If there are no cached results, that causes a PFError.
kPFCachePolicyNetworkOnly 
The query does not load from the cache, but it will save results to the cache.
kPFCachePolicyCacheElseNetwork 
The query first tries to load from the cache, but if that fails, it loads results from the network. If neither cache nor network succeed, there is a PFError.
kPFCachePolicyNetworkElseCache 
The query first tries to load from the network, but if that fails, it loads results from the cache. If neither network nor cache succeed, there is a PFError.
kPFCachePolicyCacheThenNetwork 
The query first loads from the cache, then loads from the network. In this case, the callback will actually be called twice - first with the cached results, then with the network results. Since it returns two results at different times, this cache policy cannot be used synchronously with findObjects.
If you need to control the cache's behavior, you can use methods provided in PFQuery to interact with the cache. You can do the following operations on the cache:

Check to see if there is a cached result for the query with:
BOOL isInCache = [query hasCachedResult];
Remove any cached results for a query with:
[query clearCachedResult];
Remove cached results for queries with:
[PFQuery clearAllCachedResults];
Control the maximum age of a cached result with:
query.maxCacheAge = 60 * 60 * 24;  // One day, in seconds.
Query caching also works with PFQuery helpers including getFirstObject and getObjectInBackground.
Counting Objects

If you just need to count how many objects match a query, but you do not need to retrieve the objects that match, you can use countObjects instead of findObjects. For example, to count how many games have been played by a particular player:

PFQuery *query = [PFQuery queryWithClassName:@"GameScore"];
[query whereKey:@"playername" equalTo:@"Sean Plott"];
[query countObjectsInBackgroundWithBlock:^(int count, NSError *error) {
  if (!error) {
    // The count request succeeded. Log the count
    NSLog(@"Sean has played %d games", count);
  } else {
    // The request failed
  }
}];
blockscallbacks
If you want to block the calling thread, you can also use the synchronous countObjects method.
Compound Queries

If you want to find objects that match one of several queries, you can use orQueryWithSubqueries: method. For instance, if you want to find players with either have a lot of wins or a few wins, you can do:

PFQuery *lotsOfWins = [PFQuery queryWithClassName:@"Player"];
[lotsOfWins whereKey:@"wins" greaterThan:[NSNumber numberWithInt:150]];
 
PFQuery *fewWins = [PFQuery queryWithClassName:@"Player"];
[fewWins whereKey:@"wins" lessThan:[NSNumber numberWithInt:5]];
PFQuery *query = [PFQuery orQueryWithSubqueries:[NSArray arrayWithObjects:fewWins,lotsOfWins,nil]];
[query findObjectsInBackgroundWithBlock:^(NSArray *results, NSError *error) {
  // results contains players with lots of wins or only a few wins.
  }];
blockscallbacks
You can also add more constraints to the newly created PFQuery that also need to match for the objects returned.

Files

The PFFile

PFFile lets you store application files in the cloud that would otherwise be too large or cumbersome to fit into a regular PFObject. The most common use case is storing images but you can also use it for documents, videos, music, and any other binary data (up to 10 megabytes).

Learn how to make an app that allows the user to take photos and upload it directly to Parse in our Saving Images tutorial.
Getting started with PFFile is easy. First, you'll need to have the data in NSData form and then create a PFFile with it. In this example, we'll just use a string:

NSData *data = [@"Working at Parse is great!" dataUsingEncoding:NSUTF8StringEncoding];
PFFile *file = [PFFile fileWithName:@"resume.txt" data:data];
Notice in this example that we give the file a name of resume.txt. There's two things to note here:

You don't need to worry about filename collisions. Each upload gets a unique identifier so there's no problem with uploading multiple files named resume.txt.
It's important that you give a name to the file that has a file extension. This lets Parse figure out the file type and handle it accordingly. So, if you're storing PNG images, make sure your filename ends with .png.
Next you'll want to save the file up to the cloud. As with PFObject, there are many variants of the save method you can use depending on what sort of callback and error handling suits you.

[file saveInBackground];
Finally, after the save completes, you can associate a PFFile onto a PFObject just like any other piece of data:

PFObject *jobApplication = [PFObject objectWithClassName:@"JobApplication"]
[jobApplication setObject:@"Joe Smith" forKey:@"applicantName"];
[jobApplication setObject:file         forKey:@"applicantResumeFile"];
[jobApplication saveInBackground];
Retrieving it back involves calling one of the getData variants on the PFFile. Here we retrieve the resume file off another JobApplication object:

PFFile *applicantResume = [anotherApplication objectForKey:@"applicantResumeFile"];
NSData *resumeData = [applicantResume getData];
Just like on PFObject, you will most likely want to use the background version of getData.

Images

You can easily store images by converting them to NSData and then using PFFile. Suppose you have a UIImage named image that you want to save as a PFFile:

NSData *imageData = UIImagePNGRepresentation(image);
PFFile *imageFile = [PFFile fileWithName:@"image.png" data:imageData];
[imageFile save];
 
PFObject *userPhoto = [PFObject objectWithClassName:@"UserPhoto"];
[userPhoto setObject:@"My trip to Hawaii!" forKey:@"imageName"];
[userPhoto setObject:imageFile             forKey:@"imageFile"];
[userPhoto save];
Progress

It's easy to get the progress of both uploads and downloads using PFFile using saveInBackgroundWithBlock:progressBlock: and getDataInBackgroundWithBlock:progressBlock: respectively. For example:

NSData *data = [@"Working at Parse is great!" dataUsingEncoding:NSUTF8StringEncoding];
PFFile *file = [PFFile fileWithName:@"resume.txt" data:data];
[file saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
  // Handle success or failure here ...
} progressBlock:^(int percentDone) {
  // Update your progress spinner here. percentDone will be between 0 and 100.
}];
Push Notifications

Using push notifications is a great way to add real-time messaging to your application. It allows you to stay in touch with your users and makes it possible for your users to communicate with each other.

Check out our brand new in-depth tutorial on Push Notifications!
Certificates & Keys

Apple servers use SSL certificates and keys to authenticate apps that want to send push notifications. You'll need to give Parse the right file before it can send notifications on your behalf.

Push notifications don't work in the iOS simulator so we'll assume that you have your app set up to run on your device for "specialized" development using a specific profile. If not, please follow the instructions here before proceeding.

Start off by logging into the iOS Provisioning Portal. Go to the "App IDs" section, select the appropriate app, and click "Configure."


If you don't see the "Configure" link, make sure you are logged in to Apple's Developer site as a "Team Agent", and not as a "Team Admin" account.

If you already have push notifications enabled, you'll be able to download the aps_developer_identity.cer file. Otherwise, check the "Enable for Apple Push Notification service" checkbox. Next, click "Configure" to walk through the Apple Certificate Assistant wizard. Finally, click the download button to get the file.


We recommend sticking with development while you're working on integrating your app with Parse. Once you're ready to launch and switch over to your distribution provisioning profile, it's a good idea to create a new Parse app with your production push certificate.

Double click on the app_developer_identity.cer to install it in your login keychain. Once it's installed, select it by going to the "My Certificates" category. Once selected, go to the "File" menu and select "Export Items..." to save it as a .p12 file.


Don't enter a password when asked for an "export password".


Go to the "Settings" section in your Parse console and upload your .p12 file. It will verify that you exported a good certificate that can be used with Apple's servers. After you upload the file you will be sent back to the same upload page with a notice whether your upload was successful.

Pro and Enterprise customers can upload up to five certificates, which enables pushing to multiple iOS apps from a single Parse app. For example, you could use this for pro and lite versions of an app, or for any series of related apps that are backed by the same data.

Provisioning Profiles

You'll need to regenerate your provisioning profile if you just enabled push notifications for your app.

In the Provisioning Portal, head over to "Provisioning" and find the profile you've been using. To ensure that the profile gets regenerated, edit a field and set it back to its original value if necessary. Once that's done, download the new profile and install it in Xcode as usual.

App Integration

The first thing your app needs to do is register for push notifications. Open up your main app delegate, import Parse/Parse.h in its corresponding .h file, and add the following to your didFinishLaunchingWithOptions: method:

[application registerForRemoteNotificationTypes:UIRemoteNotificationTypeBadge|
                                                UIRemoteNotificationTypeAlert|
                                                UIRemoteNotificationTypeSound];
Next, your app needs to take the device token that Apple gives it and pass it over to Parse. Insert the following code into your main app delegate:

- (void)application:(UIApplication *)application
        didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)newDeviceToken
{
    // Tell Parse about the device token.
    [PFPush storeDeviceToken:newDeviceToken];
    // Subscribe to the global broadcast channel.
    [PFPush subscribeToChannelInBackground:@""];
}
If you want to wait for confirmation that the subscription succeeded before doing other things, check out other versions of the subscribe method in the iOS API docs for PFPush.

If you did all this correctly, your app will ask the user for permission to send push notifications as soon as it launches. Give it a try! (Remember, push notifications don't work in the simulator! Be sure to run your app on a hardware device.)

Problems? Go to our Troubleshooting section to figure out what's wrong.

In-app Notification UI

iOS will automatically handle displaying push notifications for you if your app isn't running or is in the background. However, if it's active, you'll typically need to handle the UI yourself. You can do this by implementing the main app delegate's didReceiveRemoteNotification: method, or you can have Parse can handle it for you:

- (void)application:(UIApplication *)application 
        didReceiveRemoteNotification:(NSDictionary *)userInfo {
    [PFPush handlePush:userInfo];
}
Channels

Channels are a flexible way to send push notifications to segments of your users. A channel is identified by a string that starts with a letter and consists of alphanumeric characters, underscores, and dashes. Channels don't need to be explicitly created before they are used. Each instance of your application can subscribe to any number of channels at a time. Subscribing to a channel is a single method call:

[PFPush subscribeToChannelInBackground:@"yourChannelName"];
Unsubscribing from a channel is just as easy:

[PFPush unsubscribeFromChannelInBackground:@"your_channel_here"];
To get the set of channels that the current device is subscribed to:

[PFPush getSubscribedChannelsInBackgroundWithBlock:^(NSSet *channels, NSError *error) {
  // channels is an NSSet with all the subscribed channels
}];
blockscallbacks
You can use channels in a variety of ways. For example:

A sports scores app might have a channel for each team (e.g. 'giants_scores', 'yankees_scores') so that it can send scores to a team's fans whenever a game ends.
A group chat app might have a channel for each group (e.g. 'group_1', 'group_2') so that it can send messages whenever someone chats in the group.
A travel app might have have a channel for each flight (e.g. 'united_259', 'delta_30') so that it can send flight delays to users on each flight.
A chess game app might have a channel for each match (e.g. 'match_1', 'match_2') so that it can send messages when a move is made.
An app with user accounts might have a channel for each user (e.g. 'user_1', 'user_2') so that it can send messages to a user across all their devices and have users follow others in the app.
By convention, apps that want to broadcast messages to all of their users can have each user subscribe to the empty string channel, also referred to as the global broadcast channel.

Installations

An installation object represents an instance of your app being installed on a device. These objects are used to store subscription data for installations which have subscribed to one or more push notification channels. Installations have five reserved fields in their schema:

deviceType is a required string field that must be set to either "ios" or "android". It may not be changed once the object is created.
installationId is a Parse-generated string identifier. It may not be changed once the object is created and must be unique across all of an app's installations.
deviceToken is an optional Apple-generated string identifier that is only available for iOS devices with a deviceType of "ios". It may not be changed once the object is created and must be unique across all of an app's installations.
badge is a number field representing the application badge for the installation. Setting this value will update the application icon badge number and ensure that the latest badge value will be persisted to the server on the next save. Getting this value will return the current application icon badge number.
timeZone is a string field representing the system time zone of the device running this installation. It is automatically updated to match the system time zone when an installation is saved from its device.
channels is an optional array of strings representing the subscriptions of this installation object.
To let you store custom data about your app's installations, we provide a specialized installation class called PFInstallation, which is a subclass of PFObject and has most the same features, such as flexible schema, automatic persistence, and a key value interface. There are a few differences specific to installations.

Installations are designed to be modified from the device on which they are running, so we provide a method called [PFInstallation currentInstallation] that returns a PFInstallation representing the currrently-running installation. The first time this method is called it returns an installation with the deviceType and installationId of the currently-running installation, and it is cached on disk so that the latest installation data will be available whenever your app is restarted. The deviceToken field can be populated using [PFPush storeDeviceToken:token] and the timeZone field is automatically updated whenever the installation object is saved. These special fields are readonly to avoid the creation of invalid installations.

Aside from the special fields, one main difference between PFInstallation and PFObject is that the installation IDs and device tokens are guaranteed to be unique across all installations. That means that if you uploaded a device token to Parse through the REST API, and later call currentInstallation from the actual device and save the resulting object, then the saved object will automatically be merged with the existing object in the cloud and the merged data will be returned to the device. Another difference is that querying and deleting installations are disabled from the client SDKs to prevent unauthorized access.

Note that PFInstallation can be used to access and atomically modify channel subscriptions, much like the class methods in PFPush. If you plan on using PFInstallation in your code then it is recommended that you avoid using the PFPush subscription methods, because they can cause exceptions if your currentInstallation object is dirty.

Sending Notifications

There are a number of ways to send push notifications using Parse.

Web Interface

The simplest way to send push notifications is through your Parse app's console. Head over to the "Push Notifications" tab and use the provided fields to send a message to one or more of your app's channels. The REST docs describe the behavior of each field in the web interface.

From Your App

You can send push notifications directly from your app if you set "Client push enabled?" to "On" in the "Push Notifications" section of the settings tab.

To send a simple alert to all devices on the global broadcast channel, which will display an alert to iOS users and a system tray notification to Android users, do the following:

[PFPush sendPushMessageToChannelInBackground:@""
                                 withMessage:@"Red Sox win 7-0!"];
You can also send a dictionary with data that you'd like your app to receive. For example, to remind east-coast users to catch the upcoming Yankees vs Redsox game:

PFQuery *query = [PFInstallation query];
[query whereKey:@"timezone" equalTo:@"America/new_york"];
[PFPush sendPushMessageToQuery:query
                   withMessage:@"Don't forget to catch tonight's game!"
                         error:error];
The following keys in the data dictionary have special meaning in iOS:

alert is a string that displays as a standard push notification.
badge is a value that changes the badge of the application icon. This usually indicates the number of events that the user needs to catch up on. If it is set to a number, the targeted installations will have their "badge" field updated and their application icons will be badged with that value. If it is set to "Increment", each targeted installation will have its badge field incremented and the resulting value will be used as the badge in the push payload. Omitting this field will leave badges unchanged.
sound is the name of a sound file in the application bundle. The default sound is played if you specify a sound that doesn't exist or "default".
content-available is a number which should be set to 1 to signal a Newsstand app to begin a background download.
For more information on the Apple-specific parameters, see their APNs docs and Newsstand docs

.
The SDK also lets you set multiple channels, targeted device types, and an expiration for your notification. For example, to send a more complicated push which targets only iOS devices on the "REDSOX" and "YANKEES" channels, expires one day from now, displays an alert to the user, increments the application badge, and contains additional custom data, do the following:

NSDictionary *data = [NSDictionary dictionaryWithObjectsAndKeys:
    @"Score update available", @"alert",
    @"Increment", @"badge",
    @"5", @"score_REDSOX",
    @"0", @"score_YANKEES",
    @"4th", @"inning",
    nil];
PFPush *push = [PFPush push];
[push setChannels:[NSArray arrayWithObjects:@"REDSOX", @"YANKEES", nil]];
[push setPushToAndroid:false];
[push expireAfterTimeInterval:86400];
[push setData:data];
[push sendPushInBackground];
The alert, sound, and badge keys will be sent to Apple in the proper format. Everything else will just appear on the userInfo dictionary in didReceiveRemoteNotification:.

Check out the iOS API for more details and other variants of the push sending methods.

REST API

You can send push notifications from any machine using our REST API.
Troubleshooting

If your push notifications aren't working, try the following:
Make sure the Application Identifier in the YourProjectName-Info.plist file is correct.
Add the following code to your main app delegate class and inspect the error given:
- (void)application:(UIApplication *)application 
        didFailToRegisterForRemoteNotificationsWithError:(NSError *)error
{
    if ([error code] == 3010) {
        NSLog(@"Push notifications don't work in the simulator!");
    } else {
        NSLog(@"didFailToRegisterForRemoteNotificationsWithError: %@", error);
    }
}
If you get "no valid 'aps-environment' entitlement string found for application", make sure you are you indeed using the provisioning profile you regenerated and downloaded. You should not be using the Team Provisioning Profile. Go to Project -> Edit Project Settings -> Code Signing Identity to verify.
Try cleaning your project and restarting Xcode - it never hurts.
Keep in mind that iOS notifications are limited to 256 bytes. The iOS library and the API will both return an error if you exceed that limit.
Try our new in-depth tutorial on Push Notifications.
Contact us at feedback@parse.com!
Users

At the core of many apps, there is a notion of user accounts that lets users access their information in a secure manner. We provide a specialized user class called PFUser that automatically handles much of the functionality required for user account management.

With this class, you'll be able to add user account functionality in your app.

PFUser is a subclass of PFObject and has all the same features, such as flexible schema, automatic persistence, and a key value interface. All the methods that are on PFObject also exist in PFUser. The difference is that PFUser has some special additions specific to user accounts.

Properties

PFUser has several properties that set it apart from PFObject:

username: The username for the user (required).
password: The password for the user (required on signup).
email: The email address for the user (optional).
We'll go through each of these in detail as we run through the various use cases for users. Keep in mind that if you set username and email through these properties, you do not need to set it using the setObject:forKey: method — this is set for you automatically.

Signing Up

The first thing your app will do is probably ask the user to sign up. The following code illustrates a typical sign up:

- (void)myMethod {
    PFUser *user = [PFUser user];
    user.username = @"my name";
    user.password = @"my pass";
    user.email = @"email@example.com";
 
    // other fields can be set just like with PFObject
    [user setObject:@"415-392-0202" forKey:@"phone"];
 
    [user signUpInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
      if (!error) {
          // Hooray! Let them use the app now.
      } else {
          NSString *errorString = [[error userInfo] objectForKey:@"error"];
          // Show the errorString somewhere and let the user try again.
      }
    }];
}
blockscallbacks
This call will asynchronously create a new user in your Parse App. Before it does this, it also checks to make sure that both the username and email are unique. Also, it securely hashes the password in the cloud. We never store passwords in plaintext, nor will we ever transmit passwords back to the client in plaintext.

Note that we used the signUp method, not the save method. New PFUsers should always be created using the signUp method. Subsequent updates to a user can be done by calling save.

The signUp method comes in various flavors, with the ability to pass back errors, and also synchronous versions. As usual, we highly recommend using the asynchronous versions when possible, so as not to block the UI in your app. You can read more about these specific methods in our API docs.

If a signup isn't successful, you should read the error object that is returned. The most likely case is that the username or email has already been taken by another user. You should clearly communicate this to your users, and ask them try a different username.

You are free to use an email addresses as the username. Simply ask your users to enter their email, but fill it in the username property — PFUser will work as normal. We'll go over how this is handled in the reset password section.

Logging In

Of course, after you allow users to sign up, you need to let them log in to their account in the future. To do this, you can use the class method logInWithUsernameInBackground:password:.

[PFUser logInWithUsernameInBackground:@"myname" password:@"mypass"
  block:^(PFUser *user, NSError *error) {
    if (user) {
        // Do stuff after successful login.
    } else {
        // The login failed. Check error to see why.
    }
}];
blockscallbacks
Verifying Emails

Enabling email verification in an application's settings allows the application to reserve part of its experience for users with confirmed email addresses. Email verification adds the emailVerified key to the PFUser object. When a PFUser's email is set or modified, emailVerified is set to false. Parse then emails the user a link which will set emailVerified to true.

There are three emailVerified states to consider:

true - the user confirmed his or her email address by clicking on the link Parse emailed them. PFUsers can never have a true value when the user account is first created.
false - at the time the PFUser object was last refreshed, the user had not confirmed his or her email address. If emailVerified is false, consider calling refresh: on the PFUser.
missing - the PFUser was created when email verification was off or the PFUser does not have an email.
Current User

It would be bothersome if the user had to log in every time they open your app. You can avoid this by using the cached currentUser object.

Whenever you use any signup or login methods, the user is cached on disk. You can treat this cache as a session, and automatically assume the user is logged in:

PFUser *currentUser = [PFUser currentUser];
if (currentUser) {
    // do stuff with the user
} else {
    // show the signup or login screen
}
You can clear the current user by logging them out:

[PFUser logOut];
PFUser *currentUser = [PFUser currentUser]; // this will now be nil
Anonymous Users

Being able to associate data and objects with individual users is highly valuable, but sometimes you want to be able to do this without forcing a user to specify a username and password.

An anonymous user is a user that can be created without a username and password but still has all of the same capabilities as any other PFUser. After logging out, an anonymous user is abandoned, and its data is no longer accessible.

You can create an anonymous user using PFAnonymousUtils:

[PFAnonymousUtils logInWithBlock:^(PFUser *user, NSError *error) {
    if (error) {
      NSLog(@"Anonymous login failed.");
    } else {
      NSLog(@"Anonymous user logged in.");
    }
}];
You can convert an anonymous user into a regular user by setting the username and password, then calling signUp, or by logging in or linking with a service like Facebook or Twitter. The converted user will retain all of its data. To determine whether the current user is an anonymous user, you can check PFAnonymousUtils isLinkedWithUser:

if ([PFAnonymousUtils isLinkedWithUser:[PFUser currentUser]]) {
    [self enableSignUpButton];
} else {
    [self enableLogOutButton];
}
Anonymous users can also be automatically created for you without requiring a network request, so that you can begin working with your user immediately when your application starts. When you enable automatic anonymous user creation at application startup, [PFUser currentUser] will never be nil. The user will automatically be created in the cloud the first time the user or any object with a relation to the user is saved. Until that point, the user's object ID will be nil. Enabling automatic user creation makes associating data with your users painless. For example, in your application:didFinishLaunchingWithOptions: function, you might write:

[PFUser enableAutomaticUser];
[[PFUser currentUser] incrementKey:@"RunCount"];
[[PFUser currentUser] saveInBackground];
Security For User Objects

The PFUser class is secured by default. Data stored in a PFUser can only be modified by that user. By default, the data can still be read by any client. Thus, some PFUser objects are authenticated and can be modified, whereas others are read-only.

Specifically, you are not able to invoke any of the save or delete methods unless the PFUser was obtained using an authenticated method, like logIn or signUp. This ensures that only the user can alter their own data.

The following illustrates this security policy:

PFUser *user = [PFUser logInWithUsername:@"my_username" password:@"my_password"];
user.username = "my_new_username"; // attempt to change username
[user save]; // This succeeds, since the user was authenticated on the device
 
// Get the user from a non-authenticated method
PFQuery *query = [PFUser query];
PFUser *userAgain = (PFUser *)[query getObjectWithId:user.objectId];
 
userAgain.username = "another_username";
 
// This will throw an exception, since the PFUser is not authenticated
[userAgain save];
The PFUser obtained from currentUser will always be authenticated.

If you need to check if a PFUser is authenticated, you can invoke the isAuthenticated method. You do not need to check isAuthenticated with PFUser objects that are obtained via an authenticated method.

Security For Other Objects

The same security model that applies to the PFUser can be applied to other objects. For any object, you can specify which users are allowed to read the object, and which users are allowed to modify an object. To support this type of security, each object has an access control list, implemented by the PFACL class.

The simplest way to use a PFACL is to specify that an object may only be read or written by a single user. To create such an object, there must first be a logged in PFUser. Then, the ACLWithUser method generates a PFACL that limits access to that user. An object's ACL is updated when the object is saved, like any other property. Thus, to create a private note that can only be accessed by the current user:

PFObject *privateNote = [PFObject objectWithClassName:@"Note"];
[privateNote setObject:@"This note is private!" forKey:@"content"];
privateNote.ACL = [PFACL ACLWithUser:[PFUser currentUser]];
[privateNote saveInBackground];
This note will then only be accessible to the current user, although it will be accessible to any device where that user is signed in. This functionality is useful for applications where you want to enable access to user data across multiple devices, like a personal todo list.

Permissions can also be granted on a per-user basis. You can add permissions individually to a PFACL using setReadAccess:forUser: and setWriteAccess:forUser:. For example, let's say you have a message that will be sent to a group of several users, where each of them have the rights to read and delete that message:

PFObject *groupMessage = [PFObject objectWithClassName:@"Message"];
PFACL *groupACL = [PFACL ACL];
     
// userList is an NSArray with the users we are sending this message to.
for (PFUser *user in userList) {
    [groupACL setReadAccess:YES forUser:user];
    [groupACL setWriteAccess:YES forUser:user];
}
 
groupMessage.ACL = groupACL;
[groupMessage saveInBackground];
You can also grant permissions to all users at once using setPublicReadAccess: and setPublicWriteAccess:. This allows patterns like posting comments on a message board. For example, to create a post that can only be edited by its author, but can be read by anyone:

PFObject *publicPost = [PFObject objectWithClassName:@"Post"];
PFACL *postACL = [PFACL ACLWithUser:[PFUser currentUser]];
[postACL setPublicReadAccess:YES];
publicPost.ACL = postACL;
[publicPost saveInBackground];
To help ensure that your users' data is secure by default, you can set a default ACL to be applied to all newly-created PFObjects:

[PFACL setDefaultACL:defaultACL withAccessForCurrentUser:YES];
In the code above, the second parameter to setDefaultACL tells Parse to ensure that the default ACL assigned at the time of object creation allows read and write access to the current user at that time. Without this setting, you would need to reset the defaultACL every time a user logs in or out so that the current user would be granted access appropriately. With this setting, you can ignore changes to the current user until you explicitly need to grant different kinds of access.

Default ACLs make it easy to create apps that follow common access patterns. An application like Twitter, for example, where user content is generally visible to the world, might set a default ACL such as:

PFACL *defaultACL = [PFACL ACL];
[defaultACL setPublicReadAccess:YES];
[PFACL setDefaultACL:defaultACL withAccessForCurrentUser:YES];
For an app like Dropbox, where a user's data is only accessible by the user itself unless explicit permission is given, you would provide a default ACL where only the current user is given access:

[PFACL setDefaultACL:[PFACL ACL] withAccessForCurrentUser:YES];
For an application that logs data to Parse but doesn't provide any user access to that data, you would deny access to the current user while providing a restrictive ACL:

[PFACL setDefaultACL:[PFACL ACL] withAccessForCurrentUser:NO];
Operations that are forbidden, such as deleting an object that you do not have write access to, result in a kPFErrorObjectNotFound error code. For security purposes, this prevents clients from distinguishing which object ids exist but are secured, versus which object ids do not exist at all.

Resetting Passwords

It's a fact that as soon as you introduce passwords into a system, users will forget them. In such cases, our library provides a way to let them securely reset their password.

To kick off the password reset flow, ask the user for their email address, and call:

[PFUser requestPasswordResetForEmailInBackground:@"email@example.com"];
This will attempt to match the given email with the user's email or username field, and will send them a password reset email. By doing this, you can opt to have users use their email as their username, or you can collect it separately and store it in the email field.

The flow for password reset is as follows:

User requests that their password be reset by typing in their email.
Parse sends an email to their address, with a special password reset link.
User clicks on the reset link, and is directed to a special Parse page that will allow them type in a new password.
User types in a new password. Their password has now been reset to a value they specify.
Note that the messaging in this flow will reference your app by the name that you specified when you created this app on Parse.

Querying

To query for users, you need to use the special user query:

PFQuery *query = [PFUser query];
[query whereKey:@"gender" equalTo:@"female"]; // find all the women
NSArray *girls = [query findObjects];
In addition, you can use getUserObjectWithId:objectId to get a PFUser by id.

Associations

Associations involving a PFUser work right out of the box. For example, let's say you're making a blogging app. To store a new post for a user and retrieve all their posts:

PFUser *user = [PFUser currentUser];
 
// Make a new post
PFObject *post = [PFObject objectWithClassName:@"Post"];
[post setObject:@"My New Post" forKey:@"title"];
[post setObject:@"This is some great content." forKey:@"body"];
[post setObject:user forKey:@"user"];
[post save];
 
// Find all posts by the current user
PFQuery *query = [PFQuery queryWithClassName:@"Post"];
[query whereKey:@"user" equalTo:user];
NSArray *usersPosts = [query findObjects];
Users in the Data Browser

The User class is a special class that is dedicated to storing PFUser objects. In the data browser, you'll see a little person icon next to the User class:



Roles

As your app grows in scope and user-base, you may find yourself needing more coarse-grained control over access to pieces of your data than user-linked ACLs can provide. To address this requirement, Parse supports a form of Role-based Access Control. Roles provide a logical way of grouping users with common access privileges to your Parse data. Roles are named objects that contain users and other roles. Any permission granted to a role is implicitly granted to its users as well as to the users of any roles that it contains.

For example, in your application with curated content, you may have a number of users that are considered "Moderators" and can modify and delete content created by other users. You may also have a set of users that are "Administrators" and are allowed all of the same privileges as Moderators, but can also modify the global settings for the application. By adding users to these roles, you can ensure that new users can be made moderators or administrators, without having to manually grant permission to every resource for each user.

We provide a specialized class called PFRole that represents these role objects in your client code. PFRole is a subclass of PFObject, and has all of the same features, such as a flexible schema, automatic persistence, and a key value interface. All the methods that are on PFObject also exist on PFRole. The difference is that PFRole has some additions specific to management of roles.

Properties

PFRole has several properties that set it apart from PFObject:

name: The name for the role. This value is required, and can only be set once as a role is being created. The name must consist of alphanumeric characters, spaces, -, or _. This name will be used to identify the Role without needing its objectId.
users: A relation to the set of users that will inherit permissions granted to the containing role.
roles: A relation to the set of roles whose users and roles will inherit permissions granted to the containing role.
Security for Role Objects

The PFRole uses the same security scheme (ACLs) as all other objects on Parse, except that it requires an ACL to be set explicitly. Generally, only users with greatly elevated privileges (e.g. a master user or Administrator) should be able to create or modify a Role, so you should define its ACLs accordingly. Remember, if you give write-access to a PFRole to a user, that user can add other users to the role, or even delete the role altogether.

To create a new PFRole, you would write:

// By specifying no write privileges for the ACL, we can ensure the role cannot be altered.
PFACL *roleACL = [PFACL ACL];
[roleACL setPublicReadAccess:YES];
PFRole *role = [PFRole roleWithName:@"Administrator" acl:roleACL];
[role saveInBackground];
You can add users and roles that should inherit your new role's permissions through the "users" and "roles" relations on PFRole:

PFRole *role = [PFRole roleWithName:roleName acl:roleACL];
for (PFUser *user in usersToAddToRole) {
  [role.users addObject:user];
}
for (PFRole *childRole in rolesToAddToRole) {
  [role.roles addObject:childRole];
}
[role saveInBackground];
Take great care when assigning ACLs to your roles so that they can only be modified by those who should have permissions to modify them.

Security for Other Objects

Now that you have created a set of roles for use in your application, you can use them with ACLs to define the privileges that their users will receive. Each PFObject can specify a PFACL, which provides an access control list that indicates which users and roles should be granted read or write access to the object.

Giving a role read or write permission to an object is straightforward. You can either use the PFRole:

PFRole *moderators = /* Query for some PFRole */;
PFObject *wallPost = [PFObject objectWithClassName:@"WallPost"];
PFACL *postACL = [PFACL ACL];
[postACL setWriteAccess:YES forRole:moderators];
wallPost.ACL = postACL;
[wallPost saveInBackground];
You can avoid querying for a role by specifying its name for the ACL:

PFObject *wallPost = [PFObject objectWithClassName:@"WallPost"];
PFACL *postACL = [PFACL ACL];
[postACL setWriteAccess:YES forRoleWithName:@"Moderators"];
wallPost.ACL = postACL;
[wallPost saveInBackground];
Role-based PFACLs can also be used when specifying default ACLs for your application, making it easy to protect your users' data while granting access to users with additional privileges. For example, a moderated forum application might specify a default ACL like this:

PFACL *defaultACL = [PFACL ACL];
// Everybody can read objects created by this user
[defaultACL setPublicReadAccess:YES];
// Moderators can also modify these objects
[defaultACL setWriteAccess:YES forRoleWithName:@"Moderators"];
// And the user can read and modify its own objects
[PFACL setDefaultACL:defaultACL withAccessForCurrentUser:YES];
Role Hierarchy

As described above, one role can contain another, establishing a parent-child relationship between the two roles. The consequence of this relationship is that any permission granted to the parent role is implicitly granted to all of its child roles.

These types of relationships are commonly found in applications with user-managed content, such as forums. Some small subset of users are "Administrators", with the highest level of access to tweaking the application's settings, creating new forums, setting global messages, and so on. Another set of users are "Moderators", who are responsible for ensuring that the content created by users remains appropriate. Any user with Administrator privileges should also be granted the permissions of any Moderator. To establish this relationship, you would make your "Administrators" role a child role of "Moderators", like this:

PFRole *administrators = /* Your "Administrators" role */;
PFRole *moderators = /* Your "Moderators" role */;
[moderators.roles addObject:administrators];
[moderators saveInBackground];
Role Quotas

Role-based access control is a premium feature of the Parse platform. If you are on the "Basic" plan are limited to 1 custom role, which you can use to protect access for most basic applications that need broader security groups. Parse will not allow you to exceed this quota by accident, preventing you from creating new Roles until you upgrade your plan.

If your current plan is "Pro" or above, you will have an allotment of roles included with your package, and creating Roles exceeding this quota will result in additional charges.

For more information, please see our Plans page.

Facebook Users

Parse provides an easy way to integrate Facebook with your application. The Facebook SDK is included with our SDK, and integrates with the PFUser class to make linking your users to their Facebook identities easy.

Learn how to use Parse with the Facebook API to create a profile viewer application. The Integrating Facebook in iOS tutorial will teach you how to create and login PFUsers through Facebook and make queries to the Facebook Graph API.
Using our Facebook integration, you can associate an authenticated Facebook user with a PFUser. With just a few lines of code, you'll be able to provide a "log in with Facebook" option in your app, and be able to save the user's data to Parse.

Setup

To start using Facebook with Parse, you will need to do the following:

Set up a Facebook app, if you haven't already.
Add your application's Facebook Application ID on your Parse application's settings page.
Add the following where you initialize the Parse SDK, for example, like in application:didFinishLaunchingWithOptions:
[PFFacebookUtils initializeWithApplicationId:@"YOUR FACEBOOK APP ID"];
In your app delegate, add the following handler:
- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url {
    return [PFFacebookUtils handleOpenURL:url];
}
 
- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url
    sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {
    return [PFFacebookUtils handleOpenURL:url]; 
}
Add a new entry in the URL Types section of your project info, with the format "fbYOUR_FB_APP_ID":


If you encounter any issues, a good resource is the official how-to for Facebook login. Parse will handle the login flow for you, but the rest of the set-up for preparing your iOS application for Facebook integration remains the same.

Note that if you already have the Facebook SDK installed in your app, our version of the Facebook SDK will happily work alongside it. Read more about the compatibility issues.

There are two main ways to use Facebook with your Parse users: (1) to log in (or sign up) as a Facebook user and creating a PFUser, or (2) linking Facebook to an existing PFUser.

Log In & Sign Up

PFUser provides a way to allow your users to log in or sign up through Facebook. This is done by using the logInWithFacebook method like so:

[PFFacebookUtils logInWithPermissions:permissions block:^(PFUser *user, NSError *error) {
    if (!user) {
        NSLog(@"Uh oh. The user cancelled the Facebook login.");
    } else if (user.isNew) {
        NSLog(@"User signed up and logged in through Facebook!");
    } else {
        NSLog(@"User logged in through Facebook!");
    }
}];
When this code is run, the following happens:

The user is shown the Facebook login dialog.
The user authenticates via Facebook, and your app receives a callback using handleOpenUrl.
Our SDK receives the Facebook data and saves it to a PFUser. If it's a new user based on the Facebook ID, then that user is created.
Your code block is called with the user.
The permissions argument is an array of strings that specifies what permissions your app requires from the Facebook user. The PFUser integration doesn't require any permissions to work out of the box (ie. nil perfectly acceptable). Read more permissions on Facebook's developer guide.

It is up to you to record any data that you need from the Facebook user after they authenticate. To accomplish this, you'll need to do a graph query via Facebook's SDK.
Linking

If you want to associate an existing PFUser to a Facebook account, you can link it like so:

if (![PFFacebookUtils isLinkedWithUser:user]) {
    [PFFacebookUtils linkUser:user permissions:nil block:^(BOOL succeeded, NSError *error) {
        if (succeeded) {
            NSLog(@"Woohoo, user logged in with Facebook!");
        }
    }];
}
The steps that happen when linking are very similar to log in. The difference is that on successful login, the existing PFUser is updated with the Facebook information. Future logins via Facebook will now log in the user to their existing account.

If you want to unlink Facebook from a user, simply do this:

[PFFacebookUtils unlinkUserInBackground:user block:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        NSLog(@"The user is no longer associated with their Facebook account.");
    }
}];
Facebook SDK and Parse

The Facebook iOS SDK provides a main Facebook object that is the starting point for many of the interactions with Facebook's API. You can read more about their SDK here.

The Parse SDK includes the entire Facebook SDK. All the classes are namespaced with PF_ to avoid conflicts with existing libraries. So, for example, the main Facebook object class in our SDK is PF_Facebook.

Our library also manages a PF_FBSession for you. You can simply call [PFFacebookUtils session] to access the session, which can then be used with PF_FBRequests.

The PF_FBSession provided is synchronized with the current user by default, so, any requests made using the session will be on behalf of the Facebook user associated with the current PFUser. By default, we set this session as the activeSession in for the Facebook SDK so that you don't need to explicitly set the session on every request you make.

Compatibility

Even if you already have the Facebook SDK in your project, there should not be any conflicts because our version is namespaced with PF_. However, we recommend that you alter all references to use our version and remove your version of the Facebook SDK.

Additionally, the handleOpenUrl call must reference [PFFacebookUtils handleOpenURL:url] in order for the PFUser methods to work.

Twitter Users

As with Facebook, Parse also provides an easy way to integrate Twitter authentication into your application. The Parse SDK provides a straightforward way to authorize and link a Twitter account to your PFUsers. With just a few lines of code, you'll be able to provide a "log in with Twitter" option in your app, and be able to save their data to Parse.

Setup

To start using Twitter with Parse, you need to:

Set up a Twitter app, if you haven't already.
Add your application's Twitter consumer key on your Parse application's settings page.
When asked to specify a "Callback URL" for your Twitter app, please insert a valid URL. This value will not be used by your iOS or Android application, but is necessary in order to enable authentication through Twitter.
Add the following where you initialize the Parse SDK, such as in application:didFinishLaunchingWithOptions:.
[PFTwitterUtils initializeWithConsumerKey:@"YOUR CONSUMER KEY"
                           consumerSecret:@"YOUR CONSUMER SECRET"];
If you encounter any issues that are Twitter-related, a good resource is the official Twitter documentation.

There are two main ways to use Twitter with your Parse users: (1) logging in as a Twitter user and creating a PFUser, or (2) linking Twitter to an existing PFUser.

Login & Signup

PFTwitterUtils provides a way to allow your PFUsers to log in or sign up through Twitter. This is accomplished using the logInWithBlock or logInWithTarget messages:

[PFTwitterUtils logInWithBlock:^(PFUser *user, NSError *error) {
    if (!user) {
        NSLog(@"Uh oh. The user cancelled the Twitter login.");
        return;
    } else if (user.isNew) {
        NSLog(@"User signed up and logged in with Twitter!");
    } else {
        NSLog(@"User logged in with Twitter!");
    }     
}];
When this code is run, the following happens:

The user is shown the Twitter login dialog.
The user authenticates via Twitter, and your app receives a callback.
Our SDK receives the Twitter data and saves it to a PFUser. If it's a new user based on the Twitter handle, then that user is created.
Your block is called with the user.
Linking

If you want to associate an existing PFUser with a Twitter account, you can link it like so:

if (![PFTwitterUtils isLinkedWithUser:user]) {
    [PFTwitterUtils linkUser:user block:^(BOOL succeeded, NSError *error) {
        if ([PFTwitterUtils isLinkedWithUser:user]) {
            NSLog(@"Woohoo, user logged in with Twitter!");
        }
    }];
}
The steps that happen when linking are very similar to log in. The difference is that on successful login, the existing PFUser is updated with the Twitter information. Future logins via Twitter will now log the user into their existing account.

If you want to unlink Twitter from a user, simply do this:

[PFTwitterUtils unlinkUserInBackground:user block:^(BOOL succeeded, NSError *error) {
    if (!error && succeeded) {
        NSLog(@"The user is no longer associated with their Twitter account.");
    }
}];
Twitter API Calls

Our SDK provides a straightforward way to sign your API HTTP requests to the Twitter REST API when your app has a Twitter-linked PFUser. To make a request through our API, you can use the PF_Twitter singleton provided by PFTwitterUtils:

NSURL *verify = [NSURL URLWithString:@"https://api.twitter.com/1/account/verify_credentials.json"];
NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:verify];
[[PFTwitterUtils twitter] signRequest:request];
NSURLResponse *response = nil;
NSData *data = [NSURLConnection sendSynchronousRequest:request
                                     returningResponse:&response
                                                 error:&error];
GeoPoints

Parse allows you to associate real-world latitude and longitude coordinates with an object. Adding a PFGeoPoint to a PFObject allows queries to take into account the proximity of an object to a reference point. This allows you to easily do things like find out what user is closest to another user or which places are closest to a user.

Explore the use of PFGeoPoints and PFUser in a real application with our Anywall tutorial. You'll learn everything from implementing a basic user management workflow to tracking GPS location with Core Location.
PFGeoPoint

To associate a point with an object you first need to create a PFGeoPoint. For example, to create a point with latitude of 40.0 degrees and -30.0 degrees longitude:

PFGeoPoint *point = [PFGeoPoint geoPointWithLatitude:40.0 longitude:-30.0];
This point is then stored in the object as a regular field.

[placeObject setObject:point forKey:@"location"];
Note: Currently only one key in a class may be a PFGeoPoint.

Geo Queries

Now that you have a bunch of objects with spatial coordinates, it would be nice to find out which objects are closest to a point. This can be done by adding another restriction to PFQuery using whereKey:nearGeoPoint:. Getting a list of ten places that are closest to a user may look something like:

// User's location
PFGeoPoint *userGeoPoint = [userObject objectForKey:@"location"];
// Create a query for places
PFQuery *query = [PFQuery queryWithClassName:@"PlaceObject"];
// Interested in locations near user.
[query whereKey:@"location" nearGeoPoint:userGeoPoint];
// Limit what could be a lot of points.
query.limit = [NSNumber numberWithInt:10];
// Final list of objects
placesObjects = [query findObjects];
At this point placesObjects will be an array of objects ordered by distance (nearest to farthest) from userGeoPoint.

To limit the results using distance check out whereKey:nearGeoPoint:withinMiles, whereKey:nearGeoPoint:withinKilometers, and whereKey:nearGeoPoint:withinRadians.

It's also possible to query for the set of objects that are contained within a particular area. To find the objects in a rectangular bounding box, add the whereKey:withinGeoBoxFromSouthwest:toNortheast: restriction to your PFQuery.

PFGeoPoint *swOfSF = [PFGeoPoint geoPointWithLatitude:37.708813 longitude:-122.526398];
PFGeoPoint *neOfSF = [PFGeoPoint geoPointWithLatitude:37.822802 longitude:-122.373962];
PFQuery *query = [PFQuery queryWithClassName:@"PizzaPlaceObject"];
[query whereKey:@"location" withinGeoBoxFromSouthwest:swOfSF toNortheast:neOfSF];
NSArray *pizzaPlacesInSF = [query findObjects];
Caveats

At the moment there are a couple of things to watch out for:

Each PFObject class may only have one key with a PFGeoPoint object.
Points should not equal or exceed the extreme ends of the ranges. Latitude should not be -90.0 or 90.0. Longitude should not be -180.0 or 180.0. Attempting to set latitude or longitude out of bounds will cause an error.
User Interface

At the end of the day, users of your app are going to be interacting with UIKit components. Parse provides a few subclasses of UIViewController that make logging in/signing up PFUsers, and displaying PFObjects significantly easier.

PFLogInViewController

If you are using Parse to manage users in your mobile app, you are already familiar with the PFUser class. At some point in your app, you might want to present a screen to log in your PFUser. Parse provides a view controller that does exactly this.

Watch a tutorial on using the login and signup views, which provide a set of built-in views ready to be customized and dropped into your app that uses PFUser.
You use the PFLogInViewController class by instantiating it and presenting it modally:

PFLogInViewController *logInController = [[PFLogInViewController alloc] init];
logInController.delegate = self;
[self presentModalViewController:logInController animated:YES];
That is all you need to do to get a functional log in screen.

Configuring the Log In Elements


All elements of the PFLogInViewController

PFLogInViewController can be configured to provide a variety of log in options. By default, PFLogInViewController presents the following UI:

Username and Password Fields
Password Forgotten Button
LogIn Button
SignUp Button
Dismiss Button
Any of the above features can be turned on or off. The options can be set using the fields property on PFLogInViewController:

logInController.fields = PFLogInFieldsUsernameAndPassword 
        | PFLogInFieldsLogInButton
        | PFLogInFieldsSignUpButton 
        | PFLogInFieldsPasswordForgotten 
        | PFLogInFieldsDismissButton;

With username/password.


With default settings.


All elements.

Essentially, you use the bitwise or operator (|) to chain up all the options you want to include in the log in screen, and assign the value to fields.

In addition, there are a number of other options that can be turned on, including:

Facebook Button
Twitter Button
Similarly, you can turn on Facebook or Twitter log in as such:

logInController.fields = PFLogInFieldsUsernameAndPassword 
        | PFLogInFieldsFacebook
        | PFLogInFieldsTwitter;
The above code would produce a log in screen that includes username, password, Facebook and Twitter buttons. Facebook log in permissions can be set via the facebookPermissions.

PFLogInViewController *logInController = [[PFLogInViewController alloc] init];
logInController.delegate = self;
logInController.facebookPermissions = [NSArray arrayWithObjects:@"friends_about_me", nil];
[self presentModalViewController:logInController animated:YES];
Responding to Log In Success, Failure or Cancellation

When the user signs in or cancels, the PFLogInViewController notifies the delegate of the event. Upon receiving this callback, the delegate should, at a minimum, dismiss PFLogInViewController. Additionally, the delegate could possibly update its own views or forward the message to the other components that need to know about the PFUser.

- (void)logInViewController:(PFLogInViewController *)controller
               didLogInUser:(PFUser *)user {
    [self dismissModalViewControllerAnimated:YES];
}
 
- (void)logInViewControllerDidCancelLogIn:(PFLogInViewController *)logInController {
    [self dismissModalViewControllerAnimated:YES];
}
Besides the delegate pattern, the PFLogInViewController also supports the notification pattern, which is useful if there are multiple observers of the sign in events.

Customizing the Logo and Background Image

You might want to use your own logo or background image. You can achieve this by subclassing PFLogInViewController and overriding viewDidLoad:

@interface MyLogInViewController : PFLogInViewController
@end
@implementation MyLogInViewController
 
- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor colorWithPatternImage:
        [UIImage imageNamed:@"myBackgroundImage.png"]];
    label.text = @"My Logo";
    [label sizeToFit];
    self.logInView.logo = label; // logo can be any UIView
}
@end
If you would like to modify the logo and the background of the associated sign up view, you will need to subclass PFSignUpViewController and create an instance of the subclass and assign it to the signUpController as soon as you instantiate PFLogInViewController:

MyLogInViewController *logInController = [[MyLogInViewController alloc] init];
logInController.signUpController = [[MySignUpViewController alloc] init];
[self presentModalViewController:logInController animated:YES];
Further View Customization

Occasionally you might want to customize PFLogInViewController further. For example, you might want to change the placeholder text to "Email" or change the size of the login button. In both cases, you need to subclass PFLogInViewController and override either viewDidLoad or viewDidLayoutSubviews. Override the former if the behavior is not related to layout, and override the latter otherwise:

@interface MyLogInViewController : PFLogInViewController
@end
@implementation MyLogInViewController
 
- (void)viewDidLoad {
    [super viewDidLoad];
    self.logInView.usernameField.placeholder = @"email";
}
 
- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];
    self.logInView.logInButton.frame = CGRectMake(..); // set a different frame.    
}
 
@end
Developers interested in this kind of customization should take a look at the interface of PFLogInView, where all customizable properties are documented.

Portrait and Landscape

By default, the PFLogInViewController supports all orientations, except UIInterfaceOrientationPortraitUpsideDown on iPhone. One can override this behavior by subclassing and overriding shouldAutorotateToInterfaceOrientation:.

iPhone and iPad

The PFLogInViewController works on all iOS device sizes and pixel densities.

PFSignUpViewController

If you are using PFLogInViewController with the PFLogInFieldsSignUpButton option enabled, you do not need to do any additional work to enable the sign up functionality. When your user taps on the sign up button on the log in screen, a sign up screen will appear and allow them to sign up. However, there are occasions where you might want to use the sign up screen independently of the log in screen. This is when the PFSignUpViewController comes in handy.

You use PFSignUpViewController by instantiating it and presenting it modally:

PFSignUpViewController *signUpController = [[PFSignUpViewController alloc] init];
signUpController.delegate = self;
[self presentModalViewController:signUpController animated:YES];
That is all you need to do to get a functional sign up screen.

Configuring the Sign Up Elements


All elements of the PFSignUpViewController

PFSignUpViewController can be configured to provide a variety of sign up options. By default, it presents the following UI:

Username and Password Fields
Email
Sign Up Button
Dismiss Button
If your sign up screen requires an additional field on top of the default ones, such as "phone number", you can turn on a field called named "additional":

signUpController.fields = PFSignUpFieldsUsernameAndPassword 
            | PFSignUpFieldsSignUpButton 
            | PFSignUpFieldsEmail
            | PFSignUpFieldsAdditional
            | PFSignUpFieldsDismissButton;

With username/password.


With default settings.


All elements.

Essentially, you use the bitwise or operator (|) to chain up all the options you want to include in the sign up screen, and assign the value to fields. Similarly, you can turn off any field by omitting it in the assignment to fields.

Responding to Sign Up Success, Failure or Cancellation

When the user signs up or cancels, the PFSignUpViewController notifies the delegate of the event. Upon receiving this callback, the delegate should, at a minimum, dismiss PFSignUpViewController. Additionally, the delegate could update its own views or forward the message to the other components that need to know about the PFUser.

- (void)signUpViewController:(PFSignUpViewController *)signUpController didSignUpUser:(PFUser *)user {
    [self dismissModalViewControllerAnimated:YES];
}
 
- (void)signUpViewControllerDidCancelSignUp:(PFSignUpViewController *)signUpController {
    [self dismissModalViewControllerAnimated:YES];
}
Besides the delegate pattern, the PFSignUpViewController also supports NSNotification, which is useful when there are multiple listeners of the sign up events.

Customizing the Logo and Background Image

You might want to use your own logo or background image. You can achieve this by subclassing PFSignUpViewController and overriding viewDidLoad:

@interface MySignUpViewController : PFSignUpViewController
@end
@implementation MyLogInViewController
 
- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor colorWithPatternImage:
        [UIImage imageNamed:@"myBackgroundImage.png"]];
    label.text = @"My Logo";
    [label sizeToFit];
    self.signUpView.logo = label; // logo can be any UIView
}
@end
Customizing Validation Logic

Often you will want to run some client-side validation on the sign up information before submitting it to the Parse Cloud. You can add your validation logic in the signUpViewController:shouldBeginSignUp: method in the PFSignUpViewControllerDelegate. For example, if you decide any password less than 8 characters is too short, you can achieve the following with:

- (BOOL)signUpViewController:(PFSignUpViewController *)signUpController
           shouldBeginSignUp:(NSDictionary *)info {
    NSString *password = [info objectForKey:@"password"];
    return (BOOL)(password.length >= 8); // prevent sign up if password has to be at least 8 characters long
};
info is a dictionary that contains all sign up fields, such as username, password, email, and additional.

Further View Customization

Occasionally you might want to customize PFSignUpViewController further. For example, you might want to change the "additional" placeholder text to "Phone" or change the size of the signup button. You can always subclass PFSignUpViewController and override UIViewController's various methods. You should override the viewDidLoad if the behavior you want to change is unrelated to view layout, and override viewWillLayoutSubviews otherwise:

@interface MySignUpViewController : PFSignUpViewController
@end
@implementation MySignUpViewController
 
- (void)viewDidLoad {
    [super viewDidLoad];
    self.signUpView.usernameField.placeholder = @"phone";
}
 
- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];
    self.signUpView.signUpButton.frame = CGRectMake(..); // set a different frame    
}
 
@end
Developer interested in this kind of customization should take a look at the interface of PFSignUpView, where all customizable properties are documented.

Portrait and Landscape

By default, the PFSignUpViewController supports all orientations, except UIInterfaceOrientationPortraitUpsideDown on iPhone. One can override this behavior by subclassing and overriding shouldAutorotateToInterfaceOrientation:.

iPhone and iPad

The PFSignUpViewController works on all iOS device sizes and pixel densities.

PFQueryTableViewController

Data oriented iOS applications are mostly a collection of UITableViewControllers and corresponding UITableViews. When using Parse, each cell of a UITableView typically represents data from a PFObject. PFQueryTableViewController is a sub-class of UITableViewController that provides a layer of abstraction that lets you easily display data from one of your Parse classes.

Watch a tutorial on using PFQueryTableViewController to display objects from a Todo class in your Parse application.
You use PFQueryTableViewController much like how you would use UITableViewController:

Make a subclass of PFQueryTableViewController and customize it. Use the template file as a starting point.
It automatically sets itself as the delegate and datasource.
Set the className instance variable to specify which Parse class should be queried for data.
Override the queryForTable method to construct a custom PFQuery that should be used to get objects for the table.
Override the tableView:cellForRowAtIndexPath:object: method to return a custom cell tailored for each PFObject.
Implement your custom cell class; makes sure it inherits from PFTableViewCell class.
When the view loads, the class automatically grabs the PFObjects via the constructed query and loads it into the table. It even includes pagination and pull-to-refresh out of the box.
The class allows you to think about a one-to-one mapping between a PFObject and a UITableViewCell, rather than having to juggle index paths. You also get the following features out of the box:

Pagination with a cell that can be tapped to load the next page.
Pull-to-refresh table view header.
Automatic downloading and displaying of remote images in cells.
Loading screen, shown before any data is loaded.
Automatic loading and management of the objects array.
Various methods that can be overridden to customize behavior at major events in the data cycle.
The easiest way to understand this class is with an example. This subclass of PFQueryTableViewController displays a series of Todo items and their numeric priorities:

@interface SimpleTableViewController : PFQueryTableViewController
@end
       
@implementation SimpleTableViewController
 
- (id)initWithStyle:(UITableViewStyle)style
{
    self = [super initWithStyle:style];
    if (self) {
        // This table displays items in the Todo class
        self.className = @"Todo";
        self.pullToRefreshEnabled = YES;
        self.paginationEnabled = NO;
        self.objectsPerPage = 25;
    }
    return self;
}
 
- (PFQuery *)queryForTable {
    PFQuery *query = [PFQuery queryWithClassName:self.className];
  
    // If no objects are loaded in memory, we look to the cache first to fill the table
    // and then subsequently do a query against the network.
    if (self.objects.count == 0) {
        query.cachePolicy = kPFCachePolicyCacheThenNetwork;
    }
  
    [query orderByDescending:@"createdAt"];
  
    return query;
}
 
- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
                        object:(PFObject *)object
{
    static NSString *cellIdentifier = @"Cell";
     
    PFTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];
    if (!cell) {
        cell = [[PFTableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle
                                      reuseIdentifier:cellIdentifier];
    }
     
    // Configure the cell to show todo item with a priority at the bottom
    cell.textLabel.text = [object objectForKey:@"text"];
    cell.detailTextLabel.text = [NSString stringWithFormat:@"Priority: %@",
                                 [object objectForKey:@"priority"]];
     
    return cell;
}
 
@end

A query table showing Todo items.

This view shows a list of Todo items and also allows the user to pull-to-refresh and load the next page by touching a special pagination cell at the end of the table. It also properly caches the objects such that when the view is no longer in memory, the next time it loads it will use the query cache to immediately show the previously loaded objects while making a network call to update.

Notice all the code that we're not writing. We don't need to handle loading the data into the table, wrangle index paths, or handle tricky pagination code. That's all handled by the PFQueryTableViewController automatically.

A good starting point to learn more is to look at the API for the class and also the template subclass file. We designed the class with customizability in mind, so it should accommodate many instances where you used to use UITableViewController.

Loading Remote Images in Cells

PFQueryTableViewController makes it simple to display remote images stored in the Parse Cloud as PFFiles. All you need to do is to override tableView:cellForRowAtIndexPath:object: and return a PFTableViewCell with its imageView's file property specified. If you would like to display a placeholder image to be shown before the remote image is loaded, assign the placeholder image to the image property of the imageView.

@implementation SimpleTableViewController
 
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath object:(PFObject *)object {
    static NSString *identifier = @"Cell";
    PFTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];
    if (!cell) {
        cell = [[PFTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];
    }
    cell.textLabel.text = [object objectForKey:@"title"];
 
    PFFile *thumbnail = [object objectForKey:@"thumbnail"];
    cell.imageView.image = [UIImage imageNamed:@"placeholder.jpg"];
    cell.imageView.file = thumbnail;
    return cell;
}
@end

A query table that automatically downloads and displays remote images in cells.

This table shows a list of cute animal photos which are stored in the Parse Cloud, as PFFiles. "placeholder.jpg" is an image included in the application bundle which is shown before the animal photos are downloaded.

The images are downloaded on demand. As you scroll through the table, the images in the currently visible cells are downloaded. This just-in-time behavior is desirable because not only does it conserve bandwidth, it also ensures timely display of visible images. If a more aggressive loading behavior is desired, you can use the loadInBackground method on imageView to download the image.

Customizing the Query

The default query is set to get objects from your class ordered by descending createdAt. To customize, simply override the queryForTable method to return your own PFQuery. The table will use this query when getting objects to display.

Customizing the Cells

To customize the look of your table, override tableView:cellForRowAtIndexPath:object: to return a customized cell. Notice that this method is similar to the typical table data source method, but it includes the PFObject directly as a parameter.

You should no longer override tableView:cellForRowAtIndexPath:.

Important: your table view cells should inherit from PFTableViewCell, rather than UITableViewCell. PFTableViewCell is a subclass of UITableViewCell that supports remote image loading. When used in PFQueryTableViewController, PFTableViewCell's remote images would be automatically loaded.

Lifecycle Methods

Several methods are exposed that are called at major events during the data lifecycle of the table. They are objectsDidLoad: and objectsWillLoad, which are called after the objects have loaded from the query, and right before the query is fired, respectively. You can override these to provide extra functionality during these events.

Pagination


Pagination ensures that the table only gets one page of objects at a time. You can customize how many objects are in a page by setting the objectsPerPage instance variable.

The query is automatically altered to apply pagination, and, when the table first loads, it only shows the first page of objects. A pagination cell appears at the bottom of the table which allows users to load the next page. You can customize this cell by overriding tableView:cellForNextPageAtIndexPath:

Pagination is turned on by default. If you want to turn it off, simply set paginationEnabled to NO.

Pull to Refresh


Pull to Refresh is a feature that allows users to pull the table down and release to reload the data. Essentially, the first page of data is reloaded from your class and the table is cleared and updated with the data. Parse uses the EGOTableViewPullRefresh library to achieve this effect.

Pull to Refresh is turned on by default. If you want to turn it off, simply set pullToRefreshEnabled to NO.

Loading View

A loading view is displayed when the table view controller is loading the first page of data. It is turned on by default, and can be turned off via the property loadingViewEnabled.

Offline and Error Messages

When the user is offline or a Parse error was generated from a query, an alert can automatically be shown to the user. By default, this is turned on when using PFQueryTableViewController. If you want to turn this behavior off, you can do so using the methods offlineMessagesEnabled and errorMessagesEnabled on the Parse class.

PFImageView

Many apps need to display images stored in the Parse Cloud as PFFiles. However, to load remote images with the built-in UIImageView involves writing many lines of boilerplate code. PFImageView simplifies this task:

PFImageView *imageView = [[PFImageView alloc] init];
imageView.image = [UIImage imageNamed:@"..."]; // placeholder image
imageView.file = (PFFile *)[someObject objectForKey:@"picture"]; // remote image
     
[imageView loadInBackground];
If assigned to, the image property is used to display a placeholder before the remote image is downloaded. Note that the download does not start as soon as the file property is assigned to, but the loading only begins when loadInBackground: is called. The remote image is cached both in memory and on disc. If the image is found in cache, the call to loadInBackground: would return immiediately.

PFTableViewCell

Many apps need to display table view cells which contain images stored in the Parse Cloud as PFFiles. However, to load remote images with the built-in UITableViewCell involves writing many lines of boilerplate code. PFTableViewCell simplifies this task by exposing an imageView property of the type PFImageView that supports remote image loading:

@implementation SimpleTableViewController
 
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath object:(PFObject *)object {
    static NSString *identifier = @"Cell";
    PFTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];
    if (!cell) {
        cell = [[PFTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];
    }
    cell.textLabel.text = [object objectForKey:@"title"];
 
    PFFile *thumbnail = [object objectForKey:@"thumbnail"];
    cell.imageView.image = [UIImage imageNamed:@"placeholder.jpg"];
    cell.imageView.file = thumbnail;
    return cell;
}
@end
Like UITableViewCell, PFTableViewCell supports the default layout styles. Unlike UITableViewCell, PFTableViewCell's imageView property is of the type PFImageView, which supports downloading remote images in PFFile.

Although it can be used independently, PFTableViewCell really shines when used in PFQueryTableViewController. PFQueryTableViewController knows about PFTableViewCell and loads the images automatically. This behavior is discussed in detail in the documentation for PFQueryTableViewController.

Customizing/Localizing String Resources

All strings in Parse's UI classes are customizable/localizable. The easiest way to customize a string is through the default localization support provided by iOS.

Say, for example, you would like to customize the loading message in the HUD of PFSignUpViewController that says "Loading..." Assume you have followed the localization guide and set up Localizable.strings in the en.lproj directory. In Localizable.strings, you can then enter:

"Loading..." = "In progress";
That would customize the string to "In progress". The key on the left is the original string you want to customize, and the value on the right is the customized value.

Say, you would like to customize the error message in PFSignUpViewController that says "The email address "andrew@x" is invalid. Please enter a valid email." You are not sure how to enter this into Localizable.strings because it contains a variable.

Included in the Parse SDK is a file named Localizable.string which includes all the localizable keys in the Parse framework. Browsing this file, developers can find the key for the string they would like to customize. You notice that the string "The email address \"%@\" is invalid. Please enter a valid email." is a key in the file. In your own Localizable.strings, you can then enter:

"The email address \"%@\" is invalid. Please enter a valid email." = "Wrong email: \"%@\"";
The string is now customized.

In-App Purchases

Parse provides a set of APIs for working with in-app purchases. Parse makes it easier to work with StoreKit and facilitates delivery of downloadable content with receipt verification in the cloud. Receipt verification is a mechanism that allows you to restrict downloads to only those users that have paid accordingly.

In addition, developers can attach query-able metadata on products to categorize, search, and dynamically manipulate products available for purchase.

Lastly, any content uploaded to Parse is exempt from the Apple review process, and hence can be served as soon as the upload is complete.

Apple Setup

Prior to using in-app purchases on Parse, you'll need to set up your app and products with Apple. This process spans both the provisioning portal and iTunes Connect. We recommend following this step-by-step guide.

Note that this is a tricky setup process so please ensure you follow Apple's documentation precisely.

Simple Purchases

Once the setup above is complete, you can begin working with in-app purchases:

On the main thread, register the handlers for the products:

// Use the product identifier from iTunes to register a handler.
[PFPurchase addObserverForProduct:@"Pro" block:^(SKPaymentTransaction *transaction) {
    // Write business logic that should run once this product is purchased.
    isPro = YES;
}];
Note that this does not make the purchase, but simply registers a block to be run if a purchase is made later. This registration must be done on the main thread, preferably as soon as the app is launched, i.e. in application:didFinishLaunchingWithOptions:. If there are multiple products, we recommend registering all product handlers in the same method, such as application:didFinishLaunchingWithOptions:

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    ...
    [PFPurchase addObserverForProduct:@"Pro" block:^(SKPaymentTransaction *transaction) {
        isPro = YES;
    }];
    [PFPurchase addObserverForProduct:@"VIP" block:^(SKPaymentTransaction *transaction) {
        isVip = YES;
    }];
}
To initiate a purchase, use the +[PFPurchase buyProduct:block:] method:

[PFPurchase buyProduct:@"Pro" block:^(NSError *error) {
    if (!error) {
        // Run UI logic that informs user the product has been purchased, such as displaying an alert view.
    }
}];
The call to buyProduct:block: brings up a dialogue that asks users to enter their Apple credentials. When the user's identity is verified, the product will be purchased. If the product is non-consumable and has been purchased by the user before, the user will not be charged.

Downloadable Purchases

Many IAP products such as books and movies have associated content files that should be downloaded once the purchase is made. This is very simple to do with Parse:

First, go to the web data browser and create a Product collection,

For each product, fill in the required metadata information and upload the content files:

productIdentifier: the product identifier of the product, matching the one in iTunes Connect

icon: the icon to be displayed in PFProductTableViewController

title: the title to be displayed in PFProductTableViewController

subtitle: the subtitle to be displayed in PFProductTableViewController

order: the order this product should appear in PFProductTableViewController. This is used only in PFProductTableViewController; fill in 0 if the order is not important,

download: the downloadable content file

Note that the file uploaded in download is not publicly accessible, and only becomes available for download when a purchase is made. downloadName is the name of the file on disk once downoaded. You don't need to fill this in.

Next, you need to register the product handler:

[PFPurchase addObserverForProduct:@"Pro" block:^(SKPaymentTransaction *transaction) {
    [PFPurchase downloadAssetForTransaction:transaction completion:^(NSString *filePath, NSError *error) {
        if (!error) {
            // at this point, the content file is available at filePath.
        }
    }];
}];
Note that this does not make the purchase, but simply registers a block to be run if a purchase is made later. The call to downloadAssetForTransaction:completion: passes the receipt of the purchase to the Parse Cloud, which then verifies with Apple that the purchase was made. Once the receipt is verified, the purchased file is downloaded.

To make the purchase,

[PFPurchase buyProduct:@"Pro" block:^(NSError *error) {
    if (!error) {
        // run UI logic that informs user the product has been purchased, such as displaying an alert view.
    }
}];
The call to buyProduct:block: brings up a dialogue that asks users to enter their Apple credentials. When the user's identity is verified, the product will be purchased.

Querying Product Information

You can query the product objects created in the data browser using PFProduct. Like PFUser or PFRole, PFProduct is a subclass of PFObject that contains convenience accessors to various product-specific properties.

For example, here's a simple query to get a product:

PFQuery *productQuery = [PFProduct query];
PFProduct *product = [[productQuery findObjects] anyObject];
NSLog(@"%@, %@", product.productIdentifier, product.title);
PFProductTableViewController


An example of a products table in a magazine app.

PFProductTableViewController is a subclass of PFQueryTableViewController that displays all IAP products in a table view. Some content apps, such as an app that sells comic books or video tutorials, may find it handy to use PFProductTableViewController to sell the products. By default, each cell is a product, and tapping on a cell initiates the purchase for the product. If the product has associated downloadable content, the download will start when the cell is selected and a progress bar is displayed to indicate the progress of the download.

Note that in order to use this class, you must enter all product information in the Product class via the data browser.
Error Handling

Parse has a few simple patterns for surfacing errors and handling them in your code.

There are two types of errors you may encounter. The first is those dealing with logic errors in the way you're using the SDK. These types of errors result in an NSException being raised. For an example take a look at the following code:

PFUser *user = [PFUser user];
[user signUp];
This will throw an NSInternalInconsistencyException because signUp was called without first setting the required properties (username and password).

The second type of error is one that occurs when interacting with the Parse Cloud over the network. These errors are either related to problems connecting to the cloud or problems performing the requested operation. Let's take a look at another example:

- (void)getMyNote {
    PFQuery *query = [PFQuery queryWithClassName:@"Note"];
    [query getObjectInBackgroundWithId:@"thisObjectIdDoesntExist"
                                target:self
                              selector:@selector(callbackForGet:error:)];
}
In the above code, we try to fetch an object with a non-existent objectId. The Parse Cloud will return an error -- so here's how to handle it properly in your callback:

- (void)callbackForGet:(PFObject *)result error:(NSError *)error {
    if (result) {
        NSLog(@"Everything went fine!");
    } else {
        if ([error code] == kPFErrorObjectNotFound) {
            NSLog(@"Uh oh, we couldn't find the object!");
        }
    }
}
The query might also fail because the device couldn't connect to the Parse Cloud. Here's the same callback but with a bit of extra code to handle that scenario:

- (void)callbackForGet:(PFObject *)result error:(NSError *)error {
    if (result) {
        NSLog(@"Everything went fine!");
    } else {
        if ([error code] == kPFErrorObjectNotFound) {
            NSLog(@"Uh oh, we couldn't find the object!");
        // Now also check for connection errors:
        } else if ([error code] == kPFErrorConnectionFailed) {
            NSLog(@"Uh oh, we couldn't even connect to the Parse Cloud!");
        }
    }
}
When the callback expects a NSNumber, its boolValue tells you whether the operation succeeded or not. For example, this is how you might implement the callback for PFObject's saveInBackgroundWithTarget:selector: method:

- (void)callbackForSave:(NSNumber *)result error:(NSError *)error {
    if ([result boolValue]) {
        NSLog(@"Everything went fine!");
    } else {
        if ([error code] == kPFErrorConnectionFailed) {
            NSLog(@"Uh oh, we couldn't even connect to the Parse Cloud!");
        }
    }
}
For synchronous (non-background) methods, error handling is mostly the same except that instead of a NSNumber representing success or failure you'll get an actual BOOL directly.

By default, all connections have a timeout of 10 seconds, so the synchronous methods will not hang indefinitely.

For a list of all possible NSError types, see the Error Codes section of the iOS API.

Security

We strongly recommend that you build your applications to restrict access to data as much as possible. With this in mind, we recommend that you enable automatic anonymous user creation and specify a default ACL based upon the current user when your application is initialized. Explicitly set public writability (and potentially public readability) on an object-by-object basis in order to protect your data from unauthorized access.

Consider adding the following code to your application startup:

[PFUser enableAutomaticUser];
PFACL *defaultACL = [PFACL ACL];
// Optionally enable public read access while disabling public write access.
// [defaultACL setPublicReadAccess:YES];
[PFACL setDefaultACL:defaultACL withAccessForCurrentUser:YES];
Please keep secure access to your data in mind as you build your applications for the protection of both you and your users.

Settings

In addition to coding securely, please review the settings pages for your applications to select options that will restrict access to your applications as much as is appropriate for your needs. For example, if users should be unable to log in without a Facebook account linked to their application, disable all other login mechanisms. Specify your Facebook application IDs, Twitter consumer keys, and other such information to enable server-side validation of your users' login attempts.


Windows Guide

If you haven't installed the SDK yet, please head over to the QuickStart guide to get our SDK up and running in Visual Studio. Note that our SDK targets WinRT for developing Windows Store apps and requires Visual Studio 2012.

Introduction

The Parse platform provides a complete backend solution for your mobile application. Our goal is to totally eliminate the need for writing server code or maintaining servers.

If you're familiar with web frameworks like ASP.NET MVC we've taken many of the same principles and applied them to our platform. In particular, our SDK is ready to use out of the box with minimal configuration on your part.

This guide is for the .NET-based version of our SDK. If you are doing Windows 8 development using HTML and JavaScript, please see our JavaScript guide.
Parse's Windows SDK makes heavy use of the Task-based Asynchronous Pattern so that your apps remain responsive. You can use the async and await keywords in C# and Visual Basic to easily use these long-running tasks.

Apps

On Parse, you create an App for each of your mobile applications. Each App has its own application id and client key that you apply to your SDK install. Your account on Parse can accommodate multiple Apps. This is useful even if you have one application, since you can deploy different versions for test and production.

Objects

The ParseObject

Storing data on Parse is built around the ParseObject. Each ParseObject contains key-value pairs of JSON-compatible data. This data is schemaless, which means that you don't need to specify ahead of time what keys exist on each ParseObject. You simply set whatever key-value pairs you want, and our backend will store it.

For example, let's say you're tracking high scores for a game. A single ParseObject could contain:

score: 1337, playerName: "Sean Plott", cheatMode: false
Keys must start with a letter, and can contain alphanumeric characters and underscores. Values can be strings, numbers, booleans, or even arrays and dictionaries - anything that can be JSON-encoded.

Each ParseObject has a class name that you can use to distinguish different sorts of data. For example, we could call the high score object a GameScore. We recommend that you NameYourClassesLikeThis and nameYourKeysLikeThis, just to keep your code looking pretty.

Saving Objects

Let's say you want to save the GameScore described above to the Parse Cloud. The interface is similar to an IDictionary<string, object>, plus the SaveAsync method:

ParseObject gameScore = new ParseObject("GameScore");
gameScore["score"] = 1337;
gameScore["playerName"] = "Sean Plott";
await gameScore.SaveAsync();
After this code runs, you will probably be wondering if anything really happened. To make sure the data was saved, you can look at the Data Browser in your app on Parse. You should see something like this:

objectId: "xWMyZ4YEGZ", score: 1337, playerName: "Sean Plott", cheatMode: false,
createdAt:"2011-06-10T18:33:42Z", updatedAt:"2011-06-10T18:33:42Z"
There are two things to note here. You didn't have to configure or set up a new Class called GameScore before running this code. Your Parse app lazily creates this Class for you when it first encounters it.

There are also a few fields you don't need to specify that are provided as a convenience. ObjectId is a unique identifier for each saved object. CreatedAt and UpdatedAt represent the time that each object was created and last modified in the Parse Cloud. Each of these fields is filled in by Parse, so they don't exist on a ParseObject until a save operation has completed.

Data Types

So far we've used values with type string and int assigned to fields of a ParseObject. Parse also supports fields containing:

other primitive numeric values such as doubles, longs, or floats
DateTime objects
byte[] objects
objects that implement IDictionary<string, T>
objects that implement IList<T>
other ParseObject
You can nest IDictionary<string, T> and IList<T> objects to store more structured data within a single ParseObject.

Some examples:

int number = 42;
string str = "the number is " + number;
DateTime date = DateTime.Now;
byte[] data = System.Text.Encoding.UTF8.GetBytes("foo");
IList<object> list = new List<object> { str, number };
IDictionary<string, object> dictionary = new Dictionary<string, object>
{
    { "number", number },
    { "string", str }
};
 
var bigObject = new ParseObject("BigObject");
bigObject["myNumber"] = number;
bigObject["myString"] = str;
bigObject["myDate"] = date;
bigObject["myData"] = data;
bigObject["myList"] = list;
bigObject["myDictionary"] = dictionary;
await bigObject.SaveAsync();
We do not recommend storing large pieces of binary data like images or documents using byte[] fields on ParseObject. ParseObjects should not exceed 128 kilobytes in size.

For more information about how Parse handles data, check out our documentation on Data & Security.

Retrieving Objects

Saving data to the cloud is fun, but it's even more fun to get that data out again. If you have the ObjectId, you can retrieve the whole ParseObject using a ParseQuery:

ParseQuery<ParseObject> query = ParseObject.GetQuery("GameScore");
ParseObject gameScore = await query.GetAsync("xWMyZ4YEGZ");
To get the values out of the ParseObject, use the Get<T> method.

int score = gameScore.Get<int>("score");
string playerName = gameScore.Get<string>("playerName");
bool cheatMode = gameScore.Get<bool>("cheatMode");
The three special values are provided as properties:

string objectId = gameScore.ObjectId;
DateTime? updatedAt = gameScore.UpdatedAt;
DateTime? createdAt = gameScore.CreatedAt;
If you need to get an object's latest data from Parse, you can call the FetchAsync method like so:

await myObject.FetchAsync();
Updating Objects

Updating an object is simple. Just set some new data on it and call one of the save methods. For example:

// Create the object.
var gameScore = new ParseObject("GameScore")
{
    { "score", 1337 },
    { "playerName", "Sean Plott" },
    { "cheatMode", false },
    { "skills", new List<string> { "pwnage", "flying" } },
};
await gameScore.SaveAsync();
 
// Now let's update it with some new data.  In this case, only cheatMode 
// and score will get sent to the cloud.  playerName hasn't changed.
gameScore["cheatMode"] = true;
gameScore["score"] = 1338;
await gameScore.SaveAsync();
The client automatically figures out which data has changed so only "dirty" fields will be sent to Parse. You don't need to worry about squashing data that you didn't intend to update.

Counters

The above example contains a common use case. The "score" field is a counter that we'll need to continually update with the player's latest score. Using the above method works but it's cumbersome and can lead to problems if you have multiple clients trying to update the same counter.

To help with storing counter-type data, Parse provides methods that atomically increment (or decrement) any number field. So, the same update can be rewritten as:

gameScore.Increment("score");
await gameScore.SaveAsync();
You can also increment by any amount using Increment(key, amount).

Lists

To help with storing list data, there are three operations that can be used to atomically change a list field:

AddToList and AddRangeToList append the given objects to the end of an list field.
AddUniqueToList and AddRangeUniqueToList add only the given objects which aren't already contained in an list field to that field. The position of the insert is not guaranteed.
RemoveAllFromList removes all instances of each given object from an array field.
For example, we can add items to the set-like "skills" field like so:

gameScore.AddRangeUniqueToList("skills", new[] { "flying", "kungfu" });
await gameScore.SaveAsync();
Deleting Objects

To delete an object from the cloud:

await myObject.DeleteAsync();
You can delete a single field from an object with the Remove method:

// After this, the playerName field will be empty
myObject.Remove("playerName");
 
// Saves the field deletion to the Parse Cloud
await myObject.SaveAsync();
Relational Data

Objects can have relationships with other objects. To model one-to-many relationships, any ParseObject can be used as a value in other ParseObjects. Internally, the Parse framework will store the referred-to object in just one place to maintain consistency.

For example, each Comment in a blogging app might correspond to one Post. To create a new Post with a single Comment, you could write:

// Create the post
var myPost = new ParseObject("Post")
{
    { "title", "I'm Hungry" },
    { "content", "Where should we go for lunch?" }    
};
 
// Create the comment
var myComment = new ParseObject("Comment")
{
    { "content", "Let's do Sushirrito." }
};
 
// Add a relation between the Post and Comment
myComment["parent"] = myPost;
 
// This will save both myPost and myComment
await myComment.SaveAsync();
You can also link objects using just their ObjectIds like so:

myComment["parent"] = ParseObject.CreateWithoutData("Post", "1zEcyElZ80");
By default, when fetching an object, related ParseObjects are not fetched. These objects' values cannot be retrieved until they have been fetched like so:

ParseObject post = fetchedComment.Get<ParseObject>("parent");
await post.FetchIfNeededAsync();
For a many-to-many relationship, use the ParseRelation object. This works similar to a List<ParseObject>, except that you don't need to download all the objects in a relation at once. This allows ParseRelation to scale to many more objects than the List<ParseObject> approach. For example, a ParseUser may have many Posts that they might like. In this case, you can store the set of Posts that a ParseUser likes using GetRelation. In order to add a post to the list, the code would look something like:

var user = ParseUser.CurrentUser;
var relation = user.GetRelation<ParseObject>("likes");
relation.Add(post);
await user.SaveAsync();
You can remove a post from the ParseRelation with something like:

relation.Remove(post);
By default, the list of objects in this relation are not downloaded. You can get the list of Posts by using calling FindAsync on the ParseQuery returned by Query. The code would look like:

IEnumerable<ParseObject> relatedObjects = await relation.Query.FindAsync();
If you want only a subset of the Posts you can add extra constraints to the ParseQuery returned by Query like this:

var query = from post in relation.Query
            where post.CreatedAt > DateTime.Now - TimeSpan.FromDays(10)
                  // alternatively, add any other query constraints
            select post;
var relatedObjects = await query.FindAsync();
LINQMethods
For more details on ParseQuery please look at the query portion of this guide. A ParseRelation behaves similar to a List<ParseObject>, so any queries you can do on lists of objects you can do on ParseRelations.

Queries

We've already seen how a ParseQuery with GetAsync can retrieve a single ParseObject from Parse. There are many other ways to retrieve data with ParseQuery - you can retrieve many objects at once, put conditions on the objects you wish to retrieve, and more.

Basic Queries

In many cases, GetAsync isn't powerful enough to specify which objects you want to retrieve. The ParseQuery offers different ways to retrieve a list of objects rather than just a single object.

The general pattern is to create a ParseQuery, constraints to it, and then retrieve an IEnumerable of matching ParseObjectss using FindAsync. While ParseQuery supports a method-based approach for building your query, we highly recommend you use LINQ. This allows to use the full power of the LINQ C# and Visual Basic language features to create rich queries over your data.

For example, to retrieve scores with a particular playerName, use a "where" clause to constrain the value for a key.

var query = from gameScore in ParseObject.GetQuery("GameScore")
            where gameScore.Get<string>("playerName") == "Dan Stemkoski"
            select gameScore;
IEnumerable<ParseObject> results = await query.FindAsync();
LINQMethods
Query Constraints

There are several ways to put constraints on the objects found by a ParseQuery. You can filter out objects with a particular key-value pair with a LINQ where ... != ... clause or a call to WhereNotEqualTo:

var query = from gameScore in ParseObject.GetQuery("GameScore")
            where gameScore.Get<string>("playerName") != "Michael Yabuti"
            select gameScore;
LINQMethods
You can give multiple constraints, and objects will only be in the results if they match all of the constraints. In other words, it's like an AND of constraints.

// The following queries are equivalent:
var query1 = from gameScore in ParseObject.GetQuery("GameScore")
             where !gameScore.Get<string>("playerName").Equals("Michael Yabuti")
             where gameScore.Get<int>("playerAge") > 18
             select gameScore;
 
var query2 = from gameScore in ParseObject.GetQuery("GameScore")
             where !gameScore.Get<string>("playerName").Equals("Michael Yabuti")
                 && gameScore.Get<int>("playerAge") > 18
             select gameScore;
LINQMethods
You can limit the number of results by calling Limit. By default, results are limited to 100, but anything from 1 to 1000 is a valid limit:

query = query.Limit(10); // limit to at most 10 results
If you want exactly one result, a more convenient alternative may be to use FirstAsync or FirstOrDefaultAsync instead of using FindAsync.

var query = from gameScore in ParseObject.GetQuery("GameScore")
            where gameScore.Get<string>("playerEmail") == "dstemkoski@example.com"
            select gameScore;
ParseObject obj = await query.FirstAsync();
LINQMethods
You can skip the first results by calling Skip. This can be useful for pagination:

query = query.Skip(10); // skip the first 10 results
For sortable types like numbers and strings, you can control the order in which results are returned:

// Sorts the results in ascending order by score and descending order by playerName
var query = from gameScore in ParseObject.GetQuery("GameScore")
            orderby gameScore.Get<int>("score") descending, gameScore.Get<string>("playerName")
            select gameScore;
LINQMethods
For sortable types, you can also use comparisons in queries:

// Restricts to wins < 50
query = from gameScore in query
        where gameScore.Get<int>("wins") < 50
        select gameScore;
 
// Restricts to wins <= 50
query = from gameScore in query
        where gameScore.Get<int>("wins") <= 50
        select gameScore;
 
// Restricts to wins > 50
query = from gameScore in query
        where gameScore.Get<int>("wins") > 50
        select gameScore;
 
// Restricts to wins >= 50
query = from gameScore in query
        where gameScore.Get<int>("wins") >= 50
        select gameScore;
LINQMethods
If you want to retrieve objects matching several different values, you can use WhereContainedIn or a Contains LINQ query, providing an list of acceptable values. This is often useful to replace multiple queries with a single query. For example, if you want to retrieve scores made by any player in a particular list:

// Finds scores from any of Jonathan, Dario, or Shawn
var names = new[] { "Jonathan Walsh", "Dario Wunsch", "Shawn Simon" };
var query = from gameScore in ParseObject.GetQuery("GameScore")
            where names.Contains(gameScore.Get<string>("playerName"))
            select gameScore;
LINQMethods
If you want to retrieve objects that do not match any of several values you can use WhereNotContainedIn or a !Contains LINQ query, providing an list of acceptable values. For example, if you want to retrieve scores from players besides those in a list:

// Finds scores from any of Jonathan, Dario, or Shawn
var names = new[] { "Jonathan Walsh", "Dario Wunsch", "Shawn Simon" };
var query = from gameScore in ParseObject.GetQuery("GameScore")
            where !names.Contains(gameScore.Get<string>("playerName"))
            select gameScore;
LINQMethods
If you want to retrieve objects that have a particular key set, you can use WhereExists or an ContainsKey LINQ query. Conversely, if you want to retrieve objects without a particular key set, you can use WhereDoesNotExist or an !ContainsKey LINQ query.

// Finds objects that have the score set
var query = from gameScore in ParseObject.GetQuery("GameScore")
            where gameScore.ContainsKey("score")
            select gameScore;
 
// Finds objects that don't have the score set
var query = from gameScore in ParseObject.GetQuery("GameScore")
            where !gameScore[.ContainsKey("score")
            select gameScore;
LINQMethods
You can use the WhereMatchesKeyInQuery method or a join LINQ query to get objects where a key matches the value of a key in a set of objects resulting from another query. For example, if you have a class containing sports teams and you store a user's hometown in the user class, you can issue one query to find the list of users whose hometown teams have winning records. The query would look like:

var teamQuery = from team in ParseObject.GetQuery("Team")
                where team.Get<double>("winPct") > 0.5
                select team;
var userQuery = from user in ParseUser.Query
                join team in teamQuery on user["hometown"] equals team["city"]
                select user;
IEnumerable<ParseUser> results = await userQuery.FindAsync();
// results will contain users with a hometown team with a winning record
LINQMethods
Queries on List Values

For keys with an array type, you can find objects where the key's array value contains 2 by:

// Find objects where the list in listKey contains 2.
var query = from obj in ParseObject.GetQuery("MyClass")
            where obj.Get<IList<int>>("listKey").Contains(2)
            select obj;
LINQMethods
Queries on String Values

There are several ways you can search over values containing strings. For any regular expression, you can use WhereMatches to retrieve only the values that match it:

// Finds barbecue sauces that start with a capital letter and a digit.
var query = ParseObject.GetQuery("BarbecueSauce")
    .WhereMatches("name", "^[A-Z]\\d");
 
var results = await query.FindAsync();
// The sauces could have, for example, name = "A1 Steak Sauce"
Parse uses the Perl-compatible regular expression format. If you use a .NET Regex object to specify a regular expression, you must use the ECMAScript option.

ParseQuery also supports regular expression modifiers. The supported PCRE modifiers are:
i - Case insensitive search
m - Search across multiple lines of input
// Some people type "BBQ", others type "bbq". Consider them the same thing with the
// i modifier. The m modifier helps us find sauces that call themselves "bbq sauce"
// after the first line of text.
var query = ParseObject.GetQuery("BarbecueSauce")
    .WhereMatches("description", "bbq", "im");
 
var results = await query.FindAsync();
// results will contain sauces that call themselves a "bbq" sauce.
There are also several helper functions for standard string operations: substrings, prefixes, and suffixes. Use WhereContains or an Contains LINQ query to restrict to string values containing a substring:

// Finds barbecue sauces that contain the string "Extra Spicy!".
var query = from sauce in ParseObject.GetQuery("BarbecueSauce")
            where sauce.Get<string>("name").Contains("Extra Spicy!")
            select sauce;
LINQMethods
Use WhereStartsWith or a StartsWith LINQ query to restrict to string values that start with a particular string. Similar to a MySQL LIKE operator, this is indexed so it is efficient for large datasets:

// Finds barbecue sauces that start with "Big Daddy's".
var query = from sauce in ParseObject.GetQuery("BarbecueSauce")
            where sauce.Get<string>("name").StartsWith("Big Daddy's")
            select sauce;
LINQMethods
Use WhereEndsWith or an EndsWith LINQ query to restrict to string values that end with a particular string:

// Finds barbecue sauces that end with "Original Recipe".
var query = from sauce in ParseObject.GetQuery("BarbecueSauce")
            where sauce.Get<string>("name").EndsWith("Original Recipe")
            select sauce;
LINQMethods
Relational Queries

There are several ways to issue queries for relational data. If you want to retrieve objects where a field matches a particular ParseObject, you can use WhereEqualTo or a == LINQ query just like for other data types. For example, if each Comment has a Post object in its post field, you can fetch comments for a particular Post:

// Assume ParseObject myPost was previously created.
var query = from comment in ParseObject.GetQuery("Comment")
            where comment["post"] == myPost
            select comment;
 
var comments = await query.FindAsync();
// comments now contains the comments for myPost
LINQMethods
You can also do relational queries by ObjectId:

var query = from comment in ParseObject.GetQuery("Comment")
            where comment["post"] == ParseObject.ObjectWithoutData("Post", "1zEcyElZ80")
            select comment;
LINQMethods
If you want to retrieve objects where a field contains a ParseObject that matches a different query, you can use WhereMatchesQuery or a join LINQ query. Note that the default limit of 100 and maximum limit of 1000 apply to the inner query as well, so with large data sets you may need to construct queries carefully to get the desired behavior. In order to find comments for posts with images, you can do:

var imagePosts = from post in ParseObject.GetQuery("Post")
                 where post.ContainsKey("image")
                 select post;
var query = from comment in ParseObject.GetQuery("Comment")
            join post in imagePosts on comment["post"] equals post
            select comment;
 
var comments = await query.FindAsync();
// comments now contains the comments for posts with images
LINQMethods
If you want to retrieve objects where a field contains a ParseObject that does not match a different query, you can use WhereDoesNotMatchQuery. In order to find comments for posts without images, you can do:

var imagePosts = from post in ParseObject.GetQuery("Post")
                 where post.ContainsKey("image")
                 select post;
var query = ParseObject.GetQuery("Comment")
    .WhereDoesNotMatchQuery("post", imagePosts);
 
var comments = await query.FindAsync();
// comments now contains the comments for posts without images
LINQMethods
In some situations, you want to return multiple types of related objects in one query. You can do this with the Include method. For example, let's say you are retrieving the last ten comments, and you want to retrieve their related posts at the same time:

// Retrieve the most recent comments
var query = from comment in ParseObject.GetQuery("Comment")
                                       // Only retrieve the last 10 comments
                                       .Limit(10)
                                       // Include the post data with each comment
                                       .Include("post")
            orderby comment.CreatedAt descending
            select comment;
 
var comments = await comments.FindAsync();
 
// Comments now contains the last ten comments, and the "post" field
// contains an object that has already been fetched.  For example:
foreach (var comment in comments)
{
    // This does not require a network access.
    var post = comment.Get<ParseObject>("post");
    Debug.WriteLine("Post title: " + post["title"]);
}
LINQMethods
You can also do multi level includes using dot notation. If you wanted to include the post for a comment and the post's author as well you can do:

query = query.Include("post.author");
You can issue a query with multiple fields included by calling includeKey: multiple times. This functionality also works with ParseQuery helpers like FirstAsync and GetAsync

Counting Objects

If you just need to count how many objects match a query, but you do not need to retrieve the objects that match, you can use CountAsync instead of FindAsync. For example, to count how many games have been played by a particular player:

var query = from gameScore in ParseObject.GetQuery("GameScore")
            where gameScore["playerName"] == "Sean Plott"
            select gameScore;
var count = await query.CountAsync();
LINQMethods
Compound Queries

If you want to find objects that match one of several queries, you can use the Or method. For instance, if you want to find players with either have a lot of wins or a few wins, you can do:

var lotsOfWins = from player in ParseObject.GetQuery("Player")
                 where player.Get<int>("wins") > 150
                 select player;
 
var fewWins = from player in ParseObject.GetQuery("Player")
              where player.Get<int>("wins") < 5
              select player;
 
ParseQuery<ParseObject> query = lotsOfWins.Or(fewWins);
 
var results = await query.FindAsync();
// results contains players with lots of wins or only a few wins.
LINQMethods
You can also add more constraints to the newly created ParseQuery that also need to match for the objects returned.

Files

The ParseFile

ParseFile lets you store application files in the cloud that would otherwise be too large or cumbersome to fit into a regular ParseObject. The most common use case is storing images but you can also use it for documents, videos, music, and any other binary data (up to 10 megabytes).

Getting started with ParseFile is easy. First, you'll need to have the data in byte[] or Stream form and then create a ParseFile with it. In this example, we'll just use a string:

byte[] data = System.Text.Encoding.UTF8.GetBytes("Working at Parse is great!");
ParseFile file = new ParseFile("resume.txt", data);
Notice in this example that we give the file a name of resume.txt. There's two things to note here:

You don't need to worry about filename collisions. Each upload gets a unique identifier so there's no problem with uploading multiple files named resume.txt.
It's important that you give a name to the file that has a file extension. This lets Parse figure out the file type and handle it accordingly. So, if you're storing PNG images, make sure your filename ends with .png.
Next you'll want to save the file up to the cloud. As with ParseObject, you can call SaveAsync to save the file to Parse.

await file.SaveAsync();
Finally, after the save completes, you can assign a ParseFile into a ParseObject just like any other piece of data:

var jobApplication = new ParseObject("JobApplication");
jobApplication["applicantName"] = "Joe Smith";
jobApplication["applicantResumeFile"] = file;
await jobApplication.SaveAsync();
Retrieving it back involves downloading the resource at the ParseFile's Url. Here we retrieve the resume file off another JobApplication object:

var applicantResumeFile = anotherApplication.Get<ParseFile>("applicantResumeFile");
string resumeText = await new HttpClient().GetStringAsync(applicantResumeFile.Url);
Progress

It's easy to get the progress of ParseFile uploads by passing a Progress object to SaveAsync. For example:

byte[] data = System.Text.Encoding.UTF8.GetBytes("Working at Parse is great!");
ParseFile file = new ParseFile("resume.txt", data);
 
await file.SaveAsync(new Progress<ParseUploadProgressEventArgs>(e => {
    // Check e.Progress to get the progress of the file upload
});
Users

At the core of many apps, there is a notion of user accounts that lets users access their information in a secure manner. We provide a specialized user class called ParseUser that automatically handles much of the functionality required for user account management.

With this class, you'll be able to add user account functionality in your app.

ParseUser is a subclass of ParseObject and has all the same features, such as flexible schema, automatic persistence, and a key value interface. All the methods that are on ParseObject also exist in ParseUser. The difference is that ParseUser has some special additions specific to user accounts.

Properties

ParseUser has several properties that set it apart from ParseObject:

Username: The username for the user (required).
Password: The password for the user (required on signup).
Email: The email address for the user (optional).
We'll go through each of these in detail as we run through the various use cases for users. Keep in mind that if you set Username and Email through these properties, you do not need to set it using the indexer on ParseObject — this is set for you automatically.

Signing Up

The first thing your app will do is probably ask the user to sign up. The following code illustrates a typical sign up:

public async void SignUpButton_Click(object sender, RoutedEventArgs e)
{
    var user = new ParseUser()
    {
        Username = "my name",
        Password = "my pass",
        Email = "email@example.com"
    };
 
    // other fields can be set just like with ParseObject
    user["phone"] = "415-392-0202";
 
    await user.SignUpAsync();
}
This call will asynchronously create a new user in your Parse App. Before it does this, it also checks to make sure that both the username and email are unique. Also, it securely hashes the password in the cloud. We never store passwords in plaintext, nor will we ever transmit passwords back to the client in plaintext.

Note that we used the SignUpAsync method, not the SaveAsync method. New ParseUsers should always be created using the SignUpAsync method. Subsequent updates to a user can be done by calling SaveAsync.

If a signup isn't successful, you should catch the exception thrown by the SignUpAsync. The most likely case is that the username or email has already been taken by another user. You should clearly communicate this to your users, and ask them try a different username.

You are free to use an email address as the username. Simply ask your users to enter their email, but fill it in both the Username and Email properties — ParseObject will work as normal. We'll go over how this is handled in the reset password section.

Logging In

Of course, after you allow users to sign up, you need to let them log in to their account in the future. To do this, you can use the class method LogInAsync.

try
{
    await ParseUser.LogInAsync("myname", "mypass");
    // Login was successful.
}
catch (Exception e)
{
    // The login failed. Check the error to see why.
}
Verifying Emails

Enabling email verification in an application's settings allows the application to reserve part of its experience for users with confirmed email addresses. Email verification adds the emailVerified key to the ParseUser object. When a ParseUser's Email is set or modified, emailVerified is set to false. Parse then emails the user a link which will set emailVerified to true.

There are three emailVerified states to consider:

true - the user confirmed his or her email address by clicking on the link Parse emailed them. ParseUsers can never have a true value when the user account is first created.
false - at the time the ParseUser object was last refreshed, the user had not confirmed his or her email address. If emailVerified is false, consider calling FetchAsync on the ParseUser.
missing - the ParseUser was created when email verification was off or the ParseUser does not have an email.
Current User

It would be bothersome if the user had to log in every time they open your app. You can avoid this by using the cached ParseUser.CurrentUser object.

Whenever you use any signup or login methods, the user is cached on disk. You can treat this cache as a session, and automatically assume the user is logged in:

if (ParseUser.CurrentUser != null)
{
    // do stuff with the user
}
else
{
    // show the signup or login screen
}
You can clear the current user by logging them out:

ParseUser.LogOut();
var currentUser = ParseUser.CurrentUser; // this will now be null
Security For User Objects

The ParseUser class is secured by default. Data stored in a ParseUser can only be modified by that user. By default, the data can still be read by any client. Thus, some ParseUser objects are authenticated and can be modified, whereas others are read-only.

Specifically, you are not able to invoke the SaveAsync or DeleteAsync methods unless the ParseUser was obtained using an authenticated method, like LogInAsync or SignUpAsync. This ensures that only the user can alter their own data.

The following illustrates this security policy:

var user = await ParseUser.LogInAsync("my_username", "my_password");
user.Username = "my_new_username"; // attempt to change username
await user.SaveAsync(); // This succeeds, since this user was
                        // authenticated on the device
 
ParseUser.LogOut();
// Get the user from a non-authenticated method
user = await ParseUser.Query.GetAsync(user.ObjectId);
user.Username = "another_username";
 
// This will throw an exception, since the ParseUser is not authenticated
await user.SaveAsync();
The ParseUser obtained from Current will always be authenticated.

If you need to check if a ParseUser is authenticated, you can check the IsAuthenticated property. You do not need to check IsAuthenticated with ParseUser objects that are obtained via an authenticated method.

Security For Other Objects

The same security model that applies to the ParseUser can be applied to other objects. For any object, you can specify which users are allowed to read the object, and which users are allowed to modify an object. To support this type of security, each object has an access control list, implemented by the ParseACL class.

The simplest way to use a ParseACL is to specify that an object may only be read or written by a single user. To create such an object, there must first be a logged in ParseUser. Then, the ParseACL constructor generates a ParseACL that limits access to that user. An object's ACL is updated when the object is saved, like any other property. Thus, to create a private note that can only be accessed by the current user:

var privateNote = new ParseObject("Note");
privateNote["content"] = "This note is private!";
privateNote.ACL = new ParseACL(ParseUser.CurrentUser);
await privateNote.SaveAsync();
This note will then only be accessible to the current user, although it will be accessible to any device where that user is signed in. This functionality is useful for applications where you want to enable access to user data across multiple devices, like a personal todo list.

Permissions can also be granted on a per-user basis. You can add permissions individually to a ParseACL using SetReadAccess and SetWriteAccess. For example, let's say you have a message that will be sent to a group of several users, where each of them have the rights to read and delete that message:

var groupMessage = new ParseObject("Message");
var groupACL = new ParseACL();
 
// userList is an IEnumerable<ParseUser> with the users we are sending
// this message to.
foreach (var user in userList)
{
    groupACL.SetReadAccess(user, true);
    groupACL.SetWriteAccess(user, true);
}
 
groupMessage.ACL = groupACL;
await groupMessage.SaveAsync();
You can also grant permissions to all users at once using the PublicReadAccess and PublicWriteAccess properties. This allows patterns like posting comments on a message board. For example, to create a post that can only be edited by its author, but can be read by anyone:

var publicPost = new ParseObject("Post");
var postACL = new ParseACL(ParseUser.CurrentUser)
{
    PublicReadAccess = true,
    PublicWriteAccess = false
};
publicPost.ACL = postACL;
await publicPost.SaveAsync();
Operations that are forbidden, such as deleting an object that you do not have write access to, result in a ParseException with a ObjectNotFound error code. For security purposes, this prevents clients from distinguishing which object ids exist but are secured, versus which object ids do not exist at all.

Resetting Passwords

As soon as you introduce passwords into a system, users will forget them. In such cases, our library provides a way to let them securely reset their password.

To kick off the password reset flow, ask the user for their email address, and call:

await ParseUser.RequestPasswordResetAsync("email@example.com");
This will attempt to match the given email with the user's email or username field, and will send them a password reset email. By doing this, you can opt to have users use their email as their username, or you can collect it separately and store it in the email field.

The flow for password reset is as follows:

User requests that their password be reset by typing in their email.
Parse sends an email to their address, with a special password reset link.
User clicks on the reset link, and is directed to a special Parse page that will allow them type in a new password.
User types in a new password. Their password has now been reset to a value they specify.
Note that the messaging in this flow will reference your app by the name that you specified when you created this app on Parse.

Querying

To query for users, you need to use the special user query:

var women = await (from user in ParseUser.Query
                   where user.Get<string>("gender") == "female"
                   select user).FindAsync();
LINQMethods
In addition, you can use GetAsync to get a ParseUser by id.

Associations

Associations involving a ParseUser work right out of the box. For example, let's say you're making a blogging app. To store a new post for a user and retrieve all their posts:

// Make a new post
var post = new ParseObject("Post")
{
    { "title", "My New Post" },
    { "body", "This is some great content." },
    { "user", ParseUser.CurrentUser }
};
await post.SaveAsync();
 
// Find all posts by the current user
var usersPosts = await (from post in ParseObject.GetQuery("Post")
                        where post.Get<ParseUser>("user") == ParseUser.CurrentUser
                        select post).FindAsync();
LINQMethods
Users in the Data Browser

The User class is a special class that is dedicated to storing ParseUser objects. In the data browser, you'll see a little person icon next to the User class:



Roles

As your app grows in scope and user-base, you may find yourself needing more coarse-grained control over access to pieces of your data than user-linked ACLs can provide. To address this requirement, Parse supports a form of Role-based Access Control. Roles provide a logical way of grouping users with common access privileges to your Parse data. Roles are named objects that contain users and other roles. Any permission granted to a role is implicitly granted to its users as well as to the users of any roles that it contains.

For example, in your application with curated content, you may have a number of users that are considered "Moderators" and can modify and delete content created by other users. You may also have a set of users that are "Administrators" and are allowed all of the same privileges as Moderators, but can also modify the global settings for the application. By adding users to these roles, you can ensure that new users can be made moderators or administrators, without having to manually grant permission to every resource for each user.

We provide a specialized class called ParseRole that represents these role objects in your client code. ParseRole is a subclass of ParseObject, and has all of the same features, such as a flexible schema, automatic persistence, and a key value interface. All the methods that are on ParseObject also exist on ParseRole. The difference is that ParseRole has some additions specific to management of roles.

Properties

ParseRole has several properties that set it apart from ParseObject:

name: The name for the role. This value is required, must be unique, and can only be set once as a role is being created. The name must consist of alphanumeric characters, spaces, -, or _. This name will be used to identify the Role without needing its objectId.
users: A relation to the set of users that will inherit permissions granted to the containing role.
roles: A relation to the set of roles whose users and roles will inherit permissions granted to the containing role.
Security for Role Objects

The ParseRole uses the same security scheme (ACLs) as all other objects on Parse, except that it requires an ACL to be set explicitly. Generally, only users with greatly elevated privileges (e.g. a master user or Administrator) should be able to create or modify a Role, so you should define its ACLs accordingly. Remember, if you give write-access to a ParseRole to a user, that user can add other users to the role, or even delete the role altogether.

To create a new ParseRole, you would write:

// By specifying no write privileges for the ACL, we can ensure the role cannot be altered.
var roleACL = new ParseACL()
roleACL.PublicReadAccess = true;
var role = new ParseRole("Administrator", roleACL);
await role.SaveAsync();
You can add users and roles that should inherit your new role's permissions through the "users" and "roles" relations on ParseRole:

var role = new ParseRole(roleName, roleACL);
foreach (ParseUser user in usersToAddToRole)
{
    role.Users.Add(user);
}
foreach (ParseRole childRole in rolesToAddToRole)
{
    role.Roles.Add(childRole);
}
await role.SaveAsync();
Take great care when assigning ACLs to your roles so that they can only be modified by those who should have permissions to modify them.

Security for Other Objects

Now that you have created a set of roles for use in your application, you can use them with ACLs to define the privileges that their users will receive. Each ParseObject can specify a ParseACL, which provides an access control list that indicates which users and roles should be granted read or write access to the object.

Giving a role read or write permission to an object is straightforward. You can either use the ParseRole:

var moderators = await (from role in ParseRole.Query
                        where role.Name == "Moderators"
                        select role).FirstAsync();
var wallPost = new ParseObject("WallPost");
var postACL = new ParseACL();
postACL.SetRoleWriteAccess(moderators, true);
wallPost.ACL = postACL;
await wallPost.SaveAsync();
You can avoid querying for a role by specifying its name for the ACL:

var wallPost = new ParseObject("WallPost");
var postACL = new ParseACL();
postACL.SetRoleWriteAccess("Moderators", true);
wallPost.ACL = postACL;
await wallPost.SaveAsync();
Role Hierarchy

As described above, one role can contain another, establishing a parent-child relationship between the two roles. The consequence of this relationship is that any permission granted to the parent role is implicitly granted to all of its child roles.

These types of relationships are commonly found in applications with user-managed content, such as forums. Some small subset of users are "Administrators", with the highest level of access to tweaking the application's settings, creating new forums, setting global messages, and so on. Another set of users are "Moderators", who are responsible for ensuring that the content created by users remains appropriate. Any user with Administrator privileges should also be granted the permissions of any Moderator. To establish this relationship, you would make your "Administrators" role a child role of "Moderators", like this:

ParseRole administrators = /* Your "Administrators" role */;
ParseRole moderators = /* Your "Moderators" role */;
moderators.Roles.Add(administrators);
await moderators.SaveInBackground();
Role Quotas

Role-based access control is a premium feature of the Parse platform. If you are on the "Basic" plan are limited to 1 custom role, which you can use to protect access for most basic applications that need broader security groups. Parse will not allow you to exceed this quota by accident, preventing you from creating new Roles until you upgrade your plan.

If your current plan is "Pro" or above, you will have an allotment of roles included with your package, and creating Roles exceeding this quota will result in additional charges.

For more information, please see our Plans page.

GeoPoints

Parse allows you to associate real-world latitude and longitude coordinates with an object. Adding a ParseGeoPoint to a ParseObject allows queries to take into account the proximity of an object to a reference point. This allows you to easily do things like find out what user is closest to another user or which places are closest to a user.

ParseGeoPoint

To associate a point with an object you first need to create a ParseGeoPoint. For example, to create a point with latitude of 40.0 degrees and -30.0 degrees longitude:

var point = new ParseGeoPoint(40.0, -30.0);
This point is then stored in the object as a regular field.

placeObject["location"] = point;
Note: Currently only one key in a class may be a ParseGeoPoint.

Geo Queries

Now that you have a bunch of objects with spatial coordinates, it would be nice to find out which objects are closest to a point. This can be done by adding another restriction to a ParseQuery using WhereNear. Getting a list of ten places that are closest to a user may look something like:

// User's location
var userGeoPoint = ParseUser.CurrentUser.Get<ParseGeoPoint>("location");
// Create a query for places
var query = ParseObject.GetQuery("PlaceObject");
//Interested in locations near user.
query = query.WhereNear("location", userGeoPoint);
// Limit what could be a lot of points.
query = query.Limit(10);
// Final list of nearby places
var placeObjects = await query.FindAsync();
At this point placesObjects will be an IEnumerable<ParseObject> of PlaceObjects ordered by distance (nearest to farthest) from userGeoPoint.

To limit the results using distance check out WhereWithinDistance,.

It's also possible to query for the set of objects that are contained within a particular area. To find the objects in a rectangular bounding box, add the WhereWithinGeoBox restriction to your ParseQuery.

var swOfSF = new ParseGeoPoint(37.708813, -122.526398);
var neOfSF = new ParseGeoPoint(37.822802, -122.373962);
var query = ParseObject.GetQuery("PizzaPlaceObject")
    .WhereWithinGeoBox("location", swOfSF, neOfSF);
var pizzaPlacesInSF = await query.FindAsync();
Geo Distances

Parse makes it easy to find the distance between two GeoPoints and query based upon that distance. For example, to get a distance in kilometers between two points, you can use the DistanceTo method:

ParseGeoPoint p1 = /* Some location */;
ParseGeoPoint p2 = /* Some other location */;
double distanceInKm = p1.DistanceTo(p2).Kilometers;
You can also query for ParseObjects within a radius using a ParseGeoDistance. For example, to find all places within 5 miles of a user, you would use the WhereWithinDistance method:

ParseGeoPoint userGeoPoint = ParseUser.CurrentUser.Get<ParseGeoPoint>("location");
ParseQuery<ParseObject> query = ParseObject.GetQuery("PlaceObject")
    .WhereWithinDistance("location", userGeoPoint, ParseGeoDistance.FromMiles(5));
IEnumerable<ParseObject> nearbyLocations = await query.FindAsync();
// nearbyLocations contains PlaceObjects within 5 miles of the user's location
Caveats

At the moment there are a couple of things to watch out for:

Each ParseObject class may only have one key with a ParseGeoPoint object.
Points should not equal or exceed the extreme ends of the ranges. Latitude should not be -90.0 or 90.0. Longitude should not be -180.0 or 180.0. Attempting to set latitude or longitude out of bounds will cause an error.
Error Handling

Parse has a few simple patterns for surfacing errors and handling them in your code.

There are two types of errors you may encounter. The first is those dealing with logic errors in the way you're using the SDK. These types of errors result in general Exception being raised. For an example take a look at the following code:

var user = new ParseUser();
await user.SignUpAsync();
This will throw an InvalidOperationException because SignUpAsync was called without first setting the required properties (Username and Password).

The second type of error is one that occurs when interacting with the Parse Cloud over the network. These errors are either related to problems connecting to the cloud or problems performing the requested operation. Let's take a look at another example:

await ParseObject.GetQuery("Note").GetAsync("thisObjectIdDoesntExist");
In the above code, we try to fetch an object with a non-existent ObjectId. The Parse Cloud will return an error -- so here's how to handle it properly:

try
{
    await ParseObject.GetQuery("Note").GetAsync(someObjectId);
    // Everything went fine!
}
catch (ParseException e)
{
    if (e.Code == ParseException.ErrorCode.ObjectNotFound)
    {
        // Uh oh, we couldn't find the object!
    }
    else
    {
        // Some other error occurred
    }
}
By default, all connections have a timeout of 10 seconds, so tasks will not hang indefinitely.

For a list of all possible ErrorCode types, see the ParseException.ErrorCode section of the Windows API.

Security

We strongly recommend that you build your applications to restrict access to data as much as possible. With this in mind, we recommend that you specify ACLs on all of your objects. Explicitly set public writability (and potentially public readability) on an object-by-object basis in order to protect your data from unauthorized access.

Please keep secure access to your data in mind as you build your applications for the protection of both you and your users.:wq

